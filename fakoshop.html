<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebPhoto Pro - Photoshop Clone</title>
    <style>
        :root {
            --bg-dark: #2b2b2b;
            --bg-panel: #323232;
            --bg-tool: #4a4a4a;
            --text-main: #d9d9d9;
            --accent: #0078d7;
            --border: #1e1e1e;
        }

        * { box-sizing: border-box; user-select: none; }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-dark);
            color: var(--text-main);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Menu Bar */
        #menubar {
            height: 30px;
            background-color: #1f1f1f;
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 13px;
            border-bottom: 1px solid #000;
        }
        .menu-item { padding: 5px 10px; cursor: pointer; position: relative; }
        .menu-item:hover { background-color: var(--accent); color: white; }

        .dropdown-content {
            display: none;
            position: absolute;
            top: 30px;
            left: 0;
            background-color: #2b2b2b;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.5);
            z-index: 1000;
            border: 1px solid #1e1e1e;
        }

        .dropdown-content div {
            color: #d9d9d9;
            padding: 8px 16px;
            text-decoration: none;
            display: block;
            cursor: pointer;
        }

        .dropdown-content div:hover {
            background-color: var(--accent);
            color: white;
        }

        .dropdown-content hr {
            border: 0;
            border-top: 1px solid #444;
            margin: 4px 0;
        }

        .show { display: block; }

        /* Main Workspace */
        #workspace {
            display: flex;
            flex: 1;
            height: calc(100% - 30px);
        }

        /* Toolbar (Left) */
        #toolbar {
            width: 50px;
            background-color: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 5px;
        }
        .tool {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            margin-bottom: 2px;
            border-radius: 3px;
            font-size: 18px;
            color: #b0b0b0;
        }
        .tool:hover { background-color: var(--bg-tool); }
        .tool.active { background-color: var(--bg-tool); border-left: 2px solid var(--accent); color: white; }

        /* Options Bar (Top of Workspace) */
        #options-bar {
            height: 35px;
            background-color: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 15px;
            gap: 15px;
            font-size: 12px;
        }

        /* Canvas Area (Center) */
        #canvas-area {
            flex: 1;
            background-color: #1e1e1e;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
            position: relative;
        }
        #main-canvas {
            background-color: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            cursor: crosshair;
        }

        /* Panels (Right) */
        #panels {
            width: 260px;
            background-color: var(--bg-panel);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
        }
        .panel-header {
            padding: 8px 10px;
            background-color: #252525;
            font-size: 12px;
            font-weight: bold;
            border-bottom: 1px solid var(--border);
            border-top: 1px solid var(--border);
        }
        .panel-content { padding: 15px; }

        /* Controls */
        input[type="range"] { width: 100%; cursor: pointer; }
        input[type="color"] { border: none; width: 30px; height: 30px; cursor: pointer; background: none; }
        button {
            background-color: #4a4a4a; border: 1px solid #1e1e1e;
            color: white; padding: 5px 10px; cursor: pointer; width: 100%; margin-top: 5px; font-size: 11px;
        }
        button:hover { background-color: #5a5a5a; }

        /* Layers Panel */
        #layer-list {
            flex: 1;
            overflow-y: auto;
            background-color: #2b2b2b;
        }
        .layer-item {
            padding: 10px;
            border-bottom: 1px solid #383838;
            background-color: #323232;
            cursor: pointer;
            display: flex;
            align-items: center;
            font-size: 12px;
        }
        .layer-item.active { background-color: #454545; }
        .layer-eye { margin-right: 10px; color: #aaa; cursor: pointer; }

        /* Utility classes */
        .hidden { display: none !important; }

        /* Custom input styling for realism */
        .input-group { margin-bottom: 10px; }
        .input-label { display: block; margin-bottom: 5px; font-size: 11px; color: #aaa; }
    </style>
</head>
<body>

    <div id="menubar">
        <div class="menu-item" onclick="toggleMenu('file-menu')">File
            <div id="file-menu" class="dropdown-content">
                <div onclick="newFile()">New</div>
                <div onclick="document.getElementById('file-upload').click()">Open...</div>
                <hr>
                <div onclick="downloadImage()">Export as JPG</div>
                <div onclick="downloadImage()">Export as PNG</div>
            </div>
        </div>
        <div class="menu-item" onclick="toggleMenu('edit-menu')">Edit
            <div id="edit-menu" class="dropdown-content">
                <div onclick="historyManager.undo()">Undo (Ctrl+Z)</div>
                <div onclick="historyManager.redo()">Redo (Ctrl+Y)</div>
                <hr>
                <div onclick="transformLayer('scale')">Scale Layer...</div>
                <div onclick="transformLayer('rotate')">Rotate Layer...</div>
                <hr>
                <div onclick="alert('Cut/Copy/Paste not implemented (requires permissions)')">Cut</div>
                <div onclick="alert('Cut/Copy/Paste not implemented (requires permissions)')">Copy</div>
                <div onclick="alert('Cut/Copy/Paste not implemented (requires permissions)')">Paste</div>
            </div>
        </div>
        <div class="menu-item" onclick="toggleMenu('image-menu')">Image
            <div id="image-menu" class="dropdown-content">
                <div onclick="applyImageAdjustment('brightness')">Brightness/Contrast...</div>
                <div onclick="applyImageAdjustment('hue')">Hue/Saturation...</div>
                <div onclick="applyImageAdjustment('invert')">Invert</div>
            </div>
        </div>
        <div class="menu-item" onclick="toggleMenu('filter-menu')">Filter
            <div id="filter-menu" class="dropdown-content">
                <div onclick="applyImageAdjustment('blur')">Gaussian Blur...</div>
                <div onclick="applyImageAdjustment('sharpen')">Sharpen</div>
                <div onclick="applyImageAdjustment('emboss')">Emboss</div>
                <div onclick="applyImageAdjustment('pixelate')">Pixelate...</div>
                <hr>
                <div onclick="applyImageAdjustment('grayscale')">Grayscale</div>
                <div onclick="applyImageAdjustment('sepia')">Sepia</div>
            </div>
        </div>
        <div class="menu-item" onclick="toggleMenu('view-menu')">View
            <div id="view-menu" class="dropdown-content">
                <div onclick="zoomIn()">Zoom In</div>
                <div onclick="zoomOut()">Zoom Out</div>
                <div onclick="fitScreen()">Fit Screen</div>
            </div>
        </div>
        <div class="menu-item" onclick="toggleMenu('window-menu')">Window
            <div id="window-menu" class="dropdown-content">
                <div onclick="document.getElementById('panels').classList.toggle('hidden')">Toggle Panels</div>
            </div>
        </div>
        <div class="menu-item" onclick="toggleMenu('help-menu')">Help
            <div id="help-menu" class="dropdown-content">
                <div onclick="alert('WebPhoto Pro v1.0\nSimulated Photoshop Clone')">About</div>
            </div>
        </div>
    </div>

    <div id="workspace">

        <div id="toolbar">
            <div class="tool active" title="Brush Tool (B)" onclick="setTool('brush')">üñåÔ∏è</div>
            <div class="tool" title="Eraser Tool (E)" onclick="setTool('eraser')">üßº</div>
            <div class="tool" title="Move Tool (V)" onclick="setTool('move')">‚ú•</div>
            <div class="tool" title="Fill Bucket (G)" onclick="setTool('fill')">ü™£</div>
            <div class="tool" title="Eyedropper (I)" onclick="setTool('picker')">üñäÔ∏è</div>
            <div class="tool" title="Crop Tool (C)" onclick="setTool('crop')">‚úÇÔ∏è</div>
            <div class="tool" title="Rectangle (R)" onclick="setTool('rect')">‚¨ú</div>
            <div class="tool" title="Circle (C)" onclick="setTool('circle')">‚≠ï</div>
            <div class="tool" title="Line (L)" onclick="setTool('line')">üìè</div>
            <div class="tool" title="Text (T)" onclick="setTool('text')">TXT</div>
            <div class="tool" title="Marquee Select (M)" onclick="setTool('marquee')">‚öÉ</div>
            <div class="tool" title="Lasso Select (L)" onclick="setTool('lasso')">‚û∞</div>
            <div class="tool" title="Clear Selection (Esc)" onclick="selectionManager.clearSelection()">‚úñ</div>
            <div style="flex:1"></div>
            <input type="color" id="primary-color" value="#000000" title="Primary Color">
        </div>

        <div style="flex: 1; display: flex; flex-direction: column;">
            <div id="options-bar">
                <span>Size:</span>
                <input type="range" id="brush-size" min="1" max="100" value="10" style="width: 100px;">
                <span id="brush-size-val">10px</span>

                <span style="margin-left: 10px;">Opacity:</span>
                <input type="range" id="brush-opacity" min="1" max="100" value="100" style="width: 100px;">
                <span id="brush-opacity-val">100%</span>

                <span style="margin-left: auto;">Smoothing: 10%</span>
            </div>

            <div id="canvas-area">
                <canvas id="main-canvas" width="800" height="600"></canvas>
            </div>
        </div>

        <div id="panels">

            <div class="panel-header">Navigator & Info</div>
            <div class="panel-content" style="height: 150px; display:flex; justify-content:center; align-items:center; color:#555; padding: 0;">
                <canvas id="histogram-canvas" width="260" height="150" style="width: 100%; height: 100%; background: #222;"></canvas>
            </div>

            <div class="panel-header">Quick Actions</div>
            <div class="panel-content">
                <button onclick="applyImageAdjustment('brightness')">Brightness/Contrast</button>
                <button onclick="applyImageAdjustment('hue')">Hue/Saturation</button>
                <button onclick="applyImageAdjustment('invert')">Invert</button>
                <hr style="border: 0; border-top: 1px solid #444; margin: 10px 0;">
                <input type="file" id="file-upload" style="display: none;" onchange="handleFileUpload(this)">
                <button onclick="document.getElementById('file-upload').click()">Open Image</button>
            </div>

            <div class="panel-header">Layers</div>
            <div class="panel-content" style="padding: 5px;">
                <select id="blend-mode" onchange="layerManager.setBlendMode(this.value)" style="width:100%; margin-bottom:5px;">
                    <option value="source-over">Normal</option>
                    <option value="multiply">Multiply</option>
                    <option value="screen">Screen</option>
                    <option value="overlay">Overlay</option>
                    <option value="darken">Darken</option>
                    <option value="lighten">Lighten</option>
                    <option value="color-dodge">Color Dodge</option>
                    <option value="color-burn">Color Burn</option>
                    <option value="hard-light">Hard Light</option>
                    <option value="soft-light">Soft Light</option>
                    <option value="difference">Difference</option>
                    <option value="exclusion">Exclusion</option>
                </select>
                <div class="input-group">
                    <span class="input-label">Layer Opacity</span>
                    <input type="range" min="0" max="1" step="0.01" value="1" onchange="layerManager.setOpacity(this.value)">
                </div>
            </div>
            <div id="layer-list">
                <!-- Layer items populated by JS -->
            </div>
            <div class="panel-header" style="border-top:none; display:flex; justify-content:flex-end;">
                <span style="cursor:pointer; padding:0 10px;" title="New Layer" onclick="layerManager.addLayer()">üìÑ +</span>
                <span style="cursor:pointer; padding:0 10px;" title="Delete Layer" onclick="layerManager.deleteActiveLayer()">üóëÔ∏è</span>
                <span style="cursor:pointer; padding:0 10px;" title="Move Up" onclick="layerManager.moveLayer(1)">‚¨ÜÔ∏è</span>
                <span style="cursor:pointer; padding:0 10px;" title="Move Down" onclick="layerManager.moveLayer(-1)">‚¨áÔ∏è</span>
            </div>

        </div>
    </div>

    <script>
    // --- Layer System ---
class Layer {
    constructor(id, name, width, height) {
        this.id = id;
        this.name = name;
        this.visible = true;
        this.opacity = 1.0;
        this.blendMode = 'source-over';
        this.x = 0;
        this.y = 0;
        this.scaleX = 1;
        this.scaleY = 1;
        this.rotation = 0; // in radians

        // Off-screen canvas for this layer
        this.canvas = document.createElement('canvas');
        this.canvas.width = width;
        this.canvas.height = height;
        this.ctx = this.canvas.getContext('2d');
    }

    clear() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

class LayerManager {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this.layers = [];
        this.activeLayerId = null;
        this.layerCounter = 0;
    }

    addLayer(name = null) {
        this.layerCounter++;
        // Ensure unique name if auto-generated
        let newName = name || `Layer ${this.layerCounter}`;

        const layer = new Layer(this.layerCounter, newName, this.width, this.height);

        // Add to top of stack
        this.layers.push(layer);
        this.activeLayerId = layer.id;

        renderLayerList();
        renderCanvas();
        return layer;
    }

    getActiveLayer() {
        return this.layers.find(l => l.id === this.activeLayerId);
    }

    deleteActiveLayer() {
        if (this.layers.length <= 1) {
            alert("Cannot delete the last layer.");
            return;
        }
        const index = this.layers.findIndex(l => l.id === this.activeLayerId);

        // Prevent deleting if it's the only layer (redundant check but safe)
        if (index === -1) return;

        this.layers.splice(index, 1);

        // Set new active layer to the one below, or above if it was the bottom
        const newIndex = Math.max(0, index - 1);
        this.activeLayerId = this.layers[newIndex].id;

        renderLayerList();
        renderCanvas();
    }

    moveLayer(direction) { // -1 down, 1 up
        const index = this.layers.findIndex(l => l.id === this.activeLayerId);
        if (direction === -1 && index > 0) {
            [this.layers[index], this.layers[index - 1]] = [this.layers[index - 1], this.layers[index]];
        } else if (direction === 1 && index < this.layers.length - 1) {
            [this.layers[index], this.layers[index + 1]] = [this.layers[index + 1], this.layers[index]];
        }
        renderLayerList();
        renderCanvas();
    }

    toggleVisibility(id) {
        const layer = this.layers.find(l => l.id === id);
        if(layer) {
            layer.visible = !layer.visible;
            renderLayerList();
            renderCanvas();
        }
    }

    setBlendMode(mode) {
        const layer = this.getActiveLayer();
        if(layer) {
            layer.blendMode = mode;
            renderCanvas();
        }
    }

    setOpacity(value) {
        const layer = this.getActiveLayer();
        if(layer) {
            layer.opacity = value;
            renderCanvas();
        }
    }
}

// --- History System ---
class HistoryManager {
    constructor(limit = 20) {
        this.limit = limit;
        this.stack = [];
        this.pointer = -1;
    }

    saveState() {
        // Remove redo states if we are in the middle of the stack
        if (this.pointer < this.stack.length - 1) {
            this.stack = this.stack.slice(0, this.pointer + 1);
        }

        // Deep copy the current state of all layers
        const state = layerManager.layers.map(layer => {
            const newCanvas = document.createElement('canvas');
            newCanvas.width = layer.canvas.width;
            newCanvas.height = layer.canvas.height;
            newCanvas.getContext('2d').drawImage(layer.canvas, 0, 0);

            return {
                id: layer.id,
                name: layer.name,
                visible: layer.visible,
                opacity: layer.opacity,
                blendMode: layer.blendMode,
                x: layer.x,
                y: layer.y,
                scaleX: layer.scaleX || 1,
                scaleY: layer.scaleY || 1,
                rotation: layer.rotation || 0,
                canvas: newCanvas
            };
        });

        const fullState = {
            layers: state,
            activeLayerId: layerManager.activeLayerId,
            layerCounter: layerManager.layerCounter,
            // Also save canvas dimensions for crop undo
            width: layerManager.width,
            height: layerManager.height
        };

        this.stack.push(fullState);

        // Enforce limit
        if (this.stack.length > this.limit) {
            this.stack.shift();
        } else {
            this.pointer++;
        }

        console.log("State saved. Pointer:", this.pointer);
    }

    undo() {
        if (this.pointer > 0) {
            this.pointer--;
            this.restoreState(this.stack[this.pointer]);
        }
    }

    redo() {
        if (this.pointer < this.stack.length - 1) {
            this.pointer++;
            this.restoreState(this.stack[this.pointer]);
        }
    }

    restoreState(state) {
        // Restore dimensions if changed (e.g. crop)
        if (state.width !== layerManager.width || state.height !== layerManager.height) {
            mainCanvas.width = state.width;
            mainCanvas.height = state.height;
            layerManager.width = state.width;
            layerManager.height = state.height;
            selectionManager.width = state.width;
            selectionManager.height = state.height;
            selectionManager.maskCanvas.width = state.width;
            selectionManager.maskCanvas.height = state.height;
        }

        // Restore LayerManager state
        layerManager.activeLayerId = state.activeLayerId;
        layerManager.layerCounter = state.layerCounter;

        // Reconstruct layers
        layerManager.layers = state.layers.map(lData => {
            const layer = new Layer(lData.id, lData.name, lData.canvas.width, lData.canvas.height);
            layer.visible = lData.visible;
            layer.opacity = lData.opacity;
            layer.blendMode = lData.blendMode;
            layer.x = lData.x || 0;
            layer.y = lData.y || 0;
            layer.scaleX = lData.scaleX || 1;
            layer.scaleY = lData.scaleY || 1;
            layer.rotation = lData.rotation || 0;
            layer.ctx.drawImage(lData.canvas, 0, 0);
            return layer;
        });

        renderLayerList();
        renderCanvas();
        console.log("State restored. Pointer:", this.pointer);
    }
}

// --- Selection System ---
class SelectionManager {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this.hasSelection = false;

        // Mask canvas: white = selected, black/transparent = unselected
        this.maskCanvas = document.createElement('canvas');
        this.maskCanvas.width = width;
        this.maskCanvas.height = height;
        this.ctx = this.maskCanvas.getContext('2d');

        // Path storage for lasso
        this.currentPath = [];
    }

    clearSelection() {
        this.ctx.clearRect(0, 0, this.width, this.height);
        this.hasSelection = false;
        renderCanvas();
    }

    startSelection(x, y) {
        this.clearSelection();
        this.hasSelection = true;
        this.startX = x;
        this.startY = y;

        if (currentTool === 'lasso') {
            this.ctx.beginPath();
            this.ctx.moveTo(x, y);
            this.currentPath = [[x, y]];
        }
    }

    updateSelection(x, y) {
        if (!this.hasSelection) return;

        if (currentTool === 'marquee' || currentTool === 'crop') {
            this.ctx.clearRect(0, 0, this.width, this.height);
            this.ctx.fillStyle = 'rgba(0,0,0,1)'; // Use solid color for mask logic
            this.ctx.fillRect(this.startX, this.startY, x - this.startX, y - this.startY);
        } else if (currentTool === 'lasso') {
            this.ctx.lineTo(x, y);
            this.ctx.stroke();
            this.currentPath.push([x, y]);
        }

        renderCanvas();
    }

    endSelection(x, y) {
        if (currentTool === 'lasso') {
            this.ctx.clearRect(0, 0, this.width, this.height);
            this.ctx.beginPath();
            if (this.currentPath.length > 0) {
                this.ctx.moveTo(this.currentPath[0][0], this.currentPath[0][1]);
                for(let p of this.currentPath) this.ctx.lineTo(p[0], p[1]);
            }
            this.ctx.closePath();
            this.ctx.fillStyle = 'rgba(0,0,0,1)';
            this.ctx.fill();
        }
        renderCanvas();
    }

    // Apply clipping to a context based on selection
    clipContext(ctx) {
        if (!this.hasSelection) return;
        ctx.globalCompositeOperation = 'destination-in';
        ctx.drawImage(this.maskCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
    }
}

// --- Core Variables ---
const mainCanvas = document.getElementById('main-canvas');
const mainCtx = mainCanvas.getContext('2d');
const layerManager = new LayerManager(mainCanvas.width, mainCanvas.height);
const historyManager = new HistoryManager();
const selectionManager = new SelectionManager(mainCanvas.width, mainCanvas.height);

let painting = false;
let currentTool = 'brush';
let brushSize = 10;
let brushColor = '#000000';
let brushOpacity = 1;
let startX, startY; // For shape tools

// Zoom & Pan Variables
let zoomLevel = 1.0;
let panX = 0;
let panY = 0;
let isPanning = false;
let isSpacePressed = false;
let lastPanX, lastPanY;
let lastMoveX, lastMoveY; // For move tool

// --- Initialization ---
function init() {
    // Create background layer
    const bg = layerManager.addLayer('Background');
    bg.ctx.fillStyle = '#ffffff';
    bg.ctx.fillRect(0, 0, bg.canvas.width, bg.canvas.height);

    // Save initial state
    historyManager.saveState();

    renderLayerList();
    renderCanvas();
}

function renderCanvas() {
    // Clear main display canvas
    mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);

    mainCtx.save(); // Save context state before applying transforms

    // Apply Pan and Zoom
    mainCtx.translate(panX, panY);
    mainCtx.scale(zoomLevel, zoomLevel);

    // Draw pattern background (checkerboard for transparency)
    drawCheckerboard(mainCtx, mainCanvas.width, mainCanvas.height);

    // Composite layers
    layerManager.layers.forEach(layer => {
        if (!layer.visible) return;

        mainCtx.save();
        mainCtx.globalAlpha = layer.opacity;
        mainCtx.globalCompositeOperation = layer.blendMode;

        // Apply layer transformations (Translate -> Rotate -> Scale)

        // Translate to layer position
        const centerX = (layer.x || 0) + layer.canvas.width / 2;
        const centerY = (layer.y || 0) + layer.canvas.height / 2;

        mainCtx.translate(centerX, centerY);
        mainCtx.rotate(layer.rotation || 0);
        mainCtx.scale(layer.scaleX || 1, layer.scaleY || 1);
        mainCtx.translate(-centerX, -centerY);

        mainCtx.drawImage(layer.canvas, layer.x || 0, layer.y || 0);
        mainCtx.restore();
    });

    // Reset context state for overlay drawing (Selection/Crop)
    mainCtx.globalAlpha = 1.0;
    mainCtx.globalCompositeOperation = 'source-over';

    // Draw Selection Outline
    if (selectionManager.hasSelection) {
        mainCtx.save();
        mainCtx.lineWidth = 1 / zoomLevel;
        mainCtx.setLineDash([4 / zoomLevel, 4 / zoomLevel]);

        if (currentTool === 'crop') {
            // Darken area outside crop
            mainCtx.fillStyle = 'rgba(0,0,0,0.5)';
            mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);

            // Clear the selection part to reveal image (or just draw selection border)
            // Composite destination-out to clear hole?
            mainCtx.globalCompositeOperation = 'destination-out';
            mainCtx.drawImage(selectionManager.maskCanvas, 0, 0);

            // Draw crop border
            mainCtx.globalCompositeOperation = 'source-over';
            mainCtx.strokeStyle = '#fff';
            mainCtx.strokeRect(selectionManager.startX, selectionManager.startY,
                              (window.lastMouseX || selectionManager.startX) - selectionManager.startX,
                              (window.lastMouseY || selectionManager.startY) - selectionManager.startY); // Approximation, relies on updateSelection

            // Since `maskCanvas` contains the rect, we can just outline it if simple
            // But for live drag, updateSelection logic handles rendering to maskCanvas
            // We need to outline the non-transparent part of maskCanvas?

            // Better: updateSelection already fills maskCanvas.
            // We just need to visualize it nicely for Crop.
        } else {
            mainCtx.strokeStyle = '#000';
            mainCtx.globalAlpha = 0.2;
            mainCtx.fillStyle = '#00f';
            mainCtx.drawImage(selectionManager.maskCanvas, 0, 0);
        }

        mainCtx.restore();
    }

    // Draw Preview for shapes (if painting)
    if (painting && ['rect', 'circle', 'line'].includes(currentTool)) {
        drawShapePreview();
    }

    mainCtx.restore(); // Restore context to default state (no transform)

    updateHistogram(); // Update histogram after rendering
}

function drawCheckerboard(ctx, w, h) {
    const size = 10;
    ctx.fillStyle = '#ccc';
    ctx.fillRect(0,0,w,h);
    ctx.fillStyle = '#fff';
    for(let y=0; y<h; y+=size) {
        for(let x=0; x<w; x+=size) {
            if((x/size + y/size) % 2 === 0) ctx.fillRect(x,y,size,size);
        }
    }
}

function renderLayerList() {
    const list = document.getElementById('layer-list');
    list.innerHTML = '';

    // Render in reverse order (top layer at top of list)
    [...layerManager.layers].reverse().forEach(layer => {
        const item = document.createElement('div');
        item.className = `layer-item ${layer.id === layerManager.activeLayerId ? 'active' : ''}`;
        item.onclick = () => {
            layerManager.activeLayerId = layer.id;
            renderLayerList();
        };

        const eye = document.createElement('span');
        eye.className = 'layer-eye';
        eye.innerText = layer.visible ? 'üëÅÔ∏è' : '‚óã';
        eye.onclick = (e) => {
            e.stopPropagation();
            layerManager.toggleVisibility(layer.id);
        };

        const name = document.createElement('span');
        name.innerText = layer.name;

        item.appendChild(eye);
        item.appendChild(name);
        list.appendChild(item);
    });
}


// --- Event Listeners ---
mainCanvas.addEventListener('mousedown', startPosition);
mainCanvas.addEventListener('mouseup', endPosition);
mainCanvas.addEventListener('mousemove', draw);
mainCanvas.addEventListener('click', handleCanvasClick);
mainCanvas.addEventListener('wheel', handleWheel); // Zoom support
mainCanvas.addEventListener('dblclick', handleDoubleClick); // Crop confirmation

// Input Listeners
document.getElementById('brush-size').addEventListener('input', (e) => {
    brushSize = e.target.value;
    document.getElementById('brush-size-val').innerText = brushSize + 'px';
});
document.getElementById('brush-opacity').addEventListener('input', (e) => {
    brushOpacity = e.target.value / 100;
    document.getElementById('brush-opacity-val').innerText = e.target.value + '%';
});
document.getElementById('primary-color').addEventListener('input', (e) => {
    brushColor = e.target.value;
});

// --- Coordinate Helper ---
function getCanvasCoordinates(e) {
    const rect = mainCanvas.getBoundingClientRect();
    const screenX = e.clientX - rect.left;
    const screenY = e.clientY - rect.top;

    // Inverse transform
    const canvasX = (screenX - panX) / zoomLevel;
    const canvasY = (screenY - panY) / zoomLevel;

    return { x: canvasX, y: canvasY, screenX, screenY };
}


// --- Drawing Engine ---
function startPosition(e) {
    // Handle Pan Tool (Spacebar held or middle click)
    if (isSpacePressed || e.button === 1) {
        isPanning = true;
        const coords = getCanvasCoordinates(e);
        lastPanX = coords.screenX;
        lastPanY = coords.screenY;
        mainCanvas.style.cursor = 'grabbing';
        return;
    }

    const coords = getCanvasCoordinates(e);
    startX = coords.x;
    startY = coords.y;

    if (currentTool === 'move') {
        const layer = layerManager.getActiveLayer();
        if (layer) {
            painting = true;
            lastMoveX = coords.x;
            lastMoveY = coords.y;
        }
        return;
    }

    if (['fill', 'picker', 'text'].includes(currentTool)) return; // These are handled by click

    painting = true;

    if (currentTool === 'marquee' || currentTool === 'lasso' || currentTool === 'crop') {
        selectionManager.startSelection(startX, startY);
        return;
    }

    if (selectionManager.hasSelection && (currentTool === 'brush' || currentTool === 'eraser')) {
        const layer = layerManager.getActiveLayer();
        if(layer) {
            layer.ctx.save();
            layer.ctx.beginPath();
        }
    }

    if (currentTool === 'brush' || currentTool === 'eraser') {
        draw(e);
    }
}

function endPosition(e) {
    if (isPanning) {
        isPanning = false;
        mainCanvas.style.cursor = isSpacePressed ? 'grab' : getCursorForTool(currentTool);
        return;
    }

    if (painting) {
        const coords = getCanvasCoordinates(e);
        const endX = coords.x;
        const endY = coords.y;

        painting = false;

        if (currentTool === 'move') {
            historyManager.saveState();
            return;
        }

        if (currentTool === 'marquee' || currentTool === 'lasso' || currentTool === 'crop') {
            selectionManager.endSelection(endX, endY);
            if (currentTool === 'crop') {
                 // Don't crop immediately, wait for double click or enter?
                 // For now, let user see the selection.
                 // We will add a hint "Double click to Crop"
            }
            return;
        }

        const layer = layerManager.getActiveLayer();
        if(layer) {
            if (selectionManager.hasSelection) {
                 // Selection handling placeholder
            }

             // Commit shapes
            if (currentTool === 'rect') {
                layer.ctx.fillStyle = brushColor;
                layer.ctx.fillRect(startX, startY, endX - startX, endY - startY);
            } else if (currentTool === 'circle') {
                const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                layer.ctx.fillStyle = brushColor;
                layer.ctx.beginPath();
                layer.ctx.arc(startX, startY, radius, 0, Math.PI * 2);
                layer.ctx.fill();
            } else if (currentTool === 'line') {
                layer.ctx.strokeStyle = brushColor;
                layer.ctx.lineWidth = brushSize;
                layer.ctx.beginPath();
                layer.ctx.moveTo(startX, startY);
                layer.ctx.lineTo(endX, endY);
                layer.ctx.stroke();
            }

            layer.ctx.beginPath();
        }

        historyManager.saveState();
        renderCanvas();
    }
}

function draw(e) {
    const coords = getCanvasCoordinates(e);
    const x = coords.x;
    const y = coords.y;

    // Handle Panning
    if (isPanning) {
        const dx = coords.screenX - lastPanX;
        const dy = coords.screenY - lastPanY;
        panX += dx;
        panY += dy;
        lastPanX = coords.screenX;
        lastPanY = coords.screenY;
        renderCanvas();
        return;
    }

    // Update coordinates for preview
    window.lastMouseX = x;
    window.lastMouseY = y;

    if (!painting) return;

    const layer = layerManager.getActiveLayer();
    if (!layer || !layer.visible) return;

    if (currentTool === 'move') {
        const dx = x - lastMoveX;
        const dy = y - lastMoveY;
        layer.x += dx;
        layer.y += dy;
        lastMoveX = x;
        lastMoveY = y;
        renderCanvas();
        return;
    }

    // Handle Selection Tools
    if (currentTool === 'marquee' || currentTool === 'lasso' || currentTool === 'crop') {
        selectionManager.updateSelection(x, y);
        return;
    }

    // Handle Brush/Eraser (Real-time)
    if (currentTool === 'brush') {
        const ctx = layer.ctx;
        ctx.save();

        const localX = (x - layer.x);
        const localY = (y - layer.y);

        ctx.lineWidth = brushSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = `rgba(${hexToRgb(brushColor)}, ${brushOpacity})`;

        ctx.lineTo(localX, localY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(localX, localY);

        ctx.restore();
        renderCanvas();
    } else if (currentTool === 'eraser') {
        const ctx = layer.ctx;
        const localX = (x - layer.x);
        const localY = (y - layer.y);

        ctx.lineWidth = brushSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.globalCompositeOperation = 'destination-out';
        ctx.strokeStyle = `rgba(0,0,0,1)`;

        ctx.lineTo(localX, localY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(localX, localY);
        ctx.globalCompositeOperation = 'source-over';
        renderCanvas();
    } else {
        // For shapes, we just re-render to show the preview
        renderCanvas();
    }
}

function drawShapePreview() {
    const ctx = mainCtx;
    const x = window.lastMouseX;
    const y = window.lastMouseY;

    ctx.save();
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1 / zoomLevel;
    ctx.setLineDash([5 / zoomLevel, 5 / zoomLevel]);

    if (currentTool === 'rect') {
        ctx.strokeRect(startX, startY, x - startX, y - startY);
    } else if (currentTool === 'circle') {
        const radius = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
        ctx.beginPath();
        ctx.arc(startX, startY, radius, 0, Math.PI * 2);
        ctx.stroke();
    } else if (currentTool === 'line') {
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(x, y);
        ctx.stroke();
    }

    ctx.restore();
}

function handleCanvasClick(e) {
    if (isPanning) return;

    const coords = getCanvasCoordinates(e);
    const x = coords.x;
    const y = coords.y;

    const layer = layerManager.getActiveLayer();
    if (!layer || !layer.visible) return;

    // Transform to local
    const localX = x - layer.x;
    const localY = y - layer.y;

    if (currentTool === 'fill') {
        if (selectionManager.hasSelection) {
            // Selection mask is global, so we use global x,y for mask check
            const maskPixel = selectionManager.ctx.getImageData(x, y, 1, 1).data;
            if (maskPixel[3] === 0) return;
        }

        floodFill(layer, Math.floor(localX), Math.floor(localY), hexToRgba(brushColor));
        historyManager.saveState();
        renderCanvas();
    } else if (currentTool === 'picker') {
        const pixel = layer.ctx.getImageData(localX, localY, 1, 1).data;
        const hex = rgbToHex(pixel[0], pixel[1], pixel[2]);
        brushColor = hex;
        document.getElementById('primary-color').value = hex;
    } else if (currentTool === 'text') {
        const text = prompt("Enter text:", "Text Layer");
        if (text) {
            layer.ctx.font = `${brushSize * 2}px Arial`;
            layer.ctx.fillStyle = brushColor;
            layer.ctx.fillText(text, localX, localY);
            historyManager.saveState();
            renderCanvas();
        }
    }
}

function handleDoubleClick(e) {
    if (currentTool === 'crop' && selectionManager.hasSelection) {
        // Find crop bounds from mask
        // Simple approach: using selectionManager startX, startY and current mouse (or last update)
        // But the user might have dragged in any direction.
        // We need the bounding box of the selection mask.
        // Since crop tool uses rect selection logic, we can track the rect coords.

        // Find bounds of non-transparent pixels in maskCanvas
        const w = selectionManager.width;
        const h = selectionManager.height;
        const imgData = selectionManager.ctx.getImageData(0, 0, w, h);
        const data = imgData.data;

        let minX = w, minY = h, maxX = 0, maxY = 0;
        let found = false;

        for(let y=0; y<h; y++) {
            for(let x=0; x<w; x++) {
                if(data[(y*w+x)*4 + 3] > 0) {
                    if(x < minX) minX = x;
                    if(x > maxX) maxX = x;
                    if(y < minY) minY = y;
                    if(y > maxY) maxY = y;
                    found = true;
                }
            }
        }

        if(found) {
            performCrop(minX, minY, maxX - minX + 1, maxY - minY + 1);
        }
    }
}

function performCrop(x, y, w, h) {
    if (w <= 0 || h <= 0) return;

    // Resize main canvas
    mainCanvas.width = w;
    mainCanvas.height = h;
    layerManager.width = w;
    layerManager.height = h;
    selectionManager.width = w;
    selectionManager.height = h;

    // Resize mask canvas
    selectionManager.maskCanvas.width = w;
    selectionManager.maskCanvas.height = h;

    // Adjust Layers
    layerManager.layers.forEach(layer => {
        // Shift layer position
        layer.x -= x;
        layer.y -= y;

        // Note: We don't necessarily need to crop the layer internal canvas,
        // just moving it is enough to "crop" the view.
        // But if we want to save memory or fully commit, we could crop them.
        // For now, simple shift is sufficient and non-destructive to layer data (except for canvas bounds).
    });

    selectionManager.clearSelection();
    historyManager.saveState();
    renderCanvas();

    // Reset view
    panX = 0;
    panY = 0;
    zoomLevel = 1;
}

function handleWheel(e) {
    e.preventDefault();
    const zoomIntensity = 0.1;
    const delta = e.deltaY < 0 ? 1 : -1;
    const zoomFactor = Math.exp(delta * zoomIntensity);

    const rect = mainCanvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const newZoom = zoomLevel * zoomFactor;

    if (newZoom < 0.1 || newZoom > 10) return;

    const worldX = (mouseX - panX) / zoomLevel;
    const worldY = (mouseY - panY) / zoomLevel;

    panX = mouseX - worldX * newZoom;
    panY = mouseY - worldY * newZoom;
    zoomLevel = newZoom;

    renderCanvas();
}


// --- Algorithms ---

// Flood Fill (Stack-based recursive simulation)
function floodFill(layer, startX, startY, fillColor) {
    // fillColor is [r, g, b, a] (0-255)
    const ctx = layer.ctx;
    const w = layer.canvas.width;
    const h = layer.canvas.height;

    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;

    // Get selection mask data if active
    let maskData = null;
    if (selectionManager.hasSelection) {
        maskData = selectionManager.ctx.getImageData(0, 0, w, h).data;
    }

    const startPos = (startY * w + startX) * 4;
    const startColor = [data[startPos], data[startPos+1], data[startPos+2], data[startPos+3]];

    // Don't fill if color is same
    if (colorsMatch(startColor, fillColor)) return;

    const stack = [[startX, startY]];

    while(stack.length) {
        const [x, y] = stack.pop();
        const pos = (y * w + x) * 4;

        if (x < 0 || x >= w || y < 0 || y >= h) continue;

        // Check selection mask
        // Note: Mask is global. StartX/Y are local to layer.
        // We need to check mask at (x + layer.x, y + layer.y)
        if (maskData) {
            const globalX = x + layer.x;
            const globalY = y + layer.y;
            // Check bounds of mask
            if(globalX >= 0 && globalX < selectionManager.width && globalY >= 0 && globalY < selectionManager.height) {
                 const maskPos = (globalY * selectionManager.width + globalX) * 4;
                 if (maskData[maskPos + 3] === 0) continue;
            } else {
                continue; // Outside global mask area implies outside selection usually? Or unselected?
            }
        }

        if (colorsMatch([data[pos], data[pos+1], data[pos+2], data[pos+3]], startColor)) {
            data[pos] = fillColor[0];
            data[pos+1] = fillColor[1];
            data[pos+2] = fillColor[2];
            data[pos+3] = fillColor[3]; // Alpha 255

            stack.push([x+1, y]);
            stack.push([x-1, y]);
            stack.push([x, y+1]);
            stack.push([x, y-1]);
        }
    }

    ctx.putImageData(imageData, 0, 0);
}

function colorsMatch(c1, c2) {
    return c1[0] === c2[0] && c1[1] === c2[1] && c1[2] === c2[2] && c1[3] === c2[3];
}

// --- Tool Logic ---
function setTool(tool) {
    currentTool = tool;

    document.querySelectorAll('.tool').forEach(el => el.classList.remove('active'));
    const map = {
        'brush': 0, 'eraser': 1, 'move': 2, 'fill': 3, 'picker': 4, 'crop': 5,
        'rect': 6, 'circle': 7, 'line': 8, 'text': 9, 'marquee': 10, 'lasso': 11
    };
    if (document.querySelectorAll('.tool')[map[tool]]) {
        document.querySelectorAll('.tool')[map[tool]].classList.add('active');
    }

    mainCanvas.style.cursor = getCursorForTool(tool);
}

function getCursorForTool(tool) {
    if(tool === 'brush' || tool === 'eraser') return 'crosshair';
    else if(tool === 'move') return 'move';
    else if(tool === 'text') return 'text';
    else if(tool === 'picker') return 'cell';
    else if(tool === 'crop') return 'crosshair';
    return 'default';
}

// --- Color Helpers ---
function hexToRgb(hex) {
    const bigint = parseInt(hex.slice(1), 16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return `${r},${g},${b}`;
}

function hexToRgba(hex) {
    const bigint = parseInt(hex.slice(1), 16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return [r, g, b, 255];
}

function rgbToHex(r, g, b) {
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

// --- File Operations ---
function downloadImage() {
    // We need to render the final image without zoom/pan for export
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = mainCanvas.width;
    exportCanvas.height = mainCanvas.height;
    const ctx = exportCanvas.getContext('2d');

    // Replicate renderCanvas logic but flat
    drawCheckerboard(ctx, exportCanvas.width, exportCanvas.height);
    layerManager.layers.forEach(layer => {
        if (!layer.visible) return;
        ctx.save();
        ctx.globalAlpha = layer.opacity;
        ctx.globalCompositeOperation = layer.blendMode;

        const centerX = (layer.x || 0) + layer.canvas.width / 2;
        const centerY = (layer.y || 0) + layer.canvas.height / 2;
        ctx.translate(centerX, centerY);
        ctx.rotate(layer.rotation || 0);
        ctx.scale(layer.scaleX || 1, layer.scaleY || 1);
        ctx.translate(-centerX, -centerY);

        ctx.drawImage(layer.canvas, layer.x || 0, layer.y || 0);
        ctx.restore();
    });

    const link = document.createElement('a');
    link.download = 'webphoto-export.jpg';
    link.href = exportCanvas.toDataURL('image/jpeg', 0.8);
    link.click();
}

function handleFileUpload(input) {
    const file = input.files[0];
    const reader = new FileReader();

    reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
            // Create new layer for imported image
            const layer = layerManager.addLayer(file.name);
            const x = (layer.canvas.width - img.width) / 2;
            const y = (layer.canvas.height - img.height) / 2;
            layer.ctx.drawImage(img, Math.max(0, x), Math.max(0, y), Math.min(layer.canvas.width, img.width), Math.min(layer.canvas.height, img.height));
            renderCanvas();
        }
        img.src = e.target.result;
    }
    reader.readAsDataURL(file);
}

function newFile() {
    if(confirm("Clear canvas and start new?")) {
        layerManager.layers = [];
        layerManager.layerCounter = 0;
        init();
    }
}

// --- Image Adjustments (Destructive) ---
function applyImageAdjustment(type) {
    const layer = layerManager.getActiveLayer();
    if (!layer || !layer.visible) {
        alert("No active layer selected.");
        return;
    }

    const ctx = layer.ctx;
    const w = layer.canvas.width;
    const h = layer.canvas.height;

    // Get pixel data
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;

    // Get selection mask
    let maskData = null;
    if (selectionManager.hasSelection) {
        maskData = selectionManager.ctx.getImageData(0, 0, w, h).data;
    }

    // Parameters & Convolution Filters
    let val;
    if (type === 'brightness') {
        const input = prompt("Enter Brightness (-100 to 100):", "0");
        if (input === null) return;
        val = parseInt(input) || 0;
    } else if (type === 'blur') {
        const input = prompt("Enter Blur Radius (0-20):", "5");
        if (input === null) return;
        val = parseInt(input) || 0;
        // Blur handled via canvas filter
        ctx.save();
        if (selectionManager.hasSelection) selectionManager.clipContext(ctx);
        ctx.filter = `blur(${val}px)`;
        ctx.drawImage(layer.canvas, 0, 0);
        ctx.filter = 'none';
        ctx.restore();
        historyManager.saveState();
        renderCanvas();
        return;
    } else if (type === 'sharpen' || type === 'emboss') {
        // Convolution Matrix
        let kernel = [];
        if (type === 'sharpen') {
            kernel = [0, -1, 0, -1, 5, -1, 0, -1, 0];
        } else if (type === 'emboss') {
            kernel = [-2, -1, 0, -1, 1, 1, 0, 1, 2];
        }
        applyConvolution(ctx, w, h, kernel, maskData);
        historyManager.saveState();
        renderCanvas();
        return;
    } else if (type === 'pixelate') {
        const input = prompt("Enter Block Size (2-100):", "10");
        if (input === null) return;
        val = parseInt(input) || 10;
        if(val < 1) val = 1;

        // Pixelate logic: Downscale by factor, then upscale
        // But for selection support, we need to be careful.
        // Easiest per-pixel approach:

        const newImageData = ctx.createImageData(w, h);
        const newData = newImageData.data;

        for (let y = 0; y < h; y += val) {
            for (let x = 0; x < w; x += val) {
                // Get average or center pixel
                const pIndex = (y * w + x) * 4;
                const r = data[pIndex];
                const g = data[pIndex + 1];
                const b = data[pIndex + 2];
                const a = data[pIndex + 3];

                for (let py = 0; py < val; py++) {
                    for (let px = 0; px < val; px++) {
                         if (x + px >= w || y + py >= h) continue;
                         const idx = ((y + py) * w + (x + px)) * 4;

                         // Check selection
                         if (maskData && maskData[idx+3] === 0) {
                             newData[idx] = data[idx];
                             newData[idx+1] = data[idx+1];
                             newData[idx+2] = data[idx+2];
                             newData[idx+3] = data[idx+3];
                         } else {
                             newData[idx] = r;
                             newData[idx+1] = g;
                             newData[idx+2] = b;
                             newData[idx+3] = a;
                         }
                    }
                }
            }
        }
        ctx.putImageData(newImageData, 0, 0);
        historyManager.saveState();
        renderCanvas();
        return;

    } else if (type === 'hue') {
        const input = prompt("Enter Hue Shift in Degrees (0-360):", "180");
        if (input === null) return;
        val = parseInt(input) || 0;
    }

    // Process Pixels (Color Adjustments)
    for (let i = 0; i < data.length; i += 4) {
        // Skip unselected pixels
        if (maskData && maskData[i+3] === 0) continue;

        if (type === 'invert') {
            data[i] = 255 - data[i];     // R
            data[i+1] = 255 - data[i+1]; // G
            data[i+2] = 255 - data[i+2]; // B
        } else if (type === 'grayscale') {
            const avg = (data[i] + data[i+1] + data[i+2]) / 3;
            data[i] = avg;
            data[i+1] = avg;
            data[i+2] = avg;
        } else if (type === 'sepia') {
            const r = data[i], g = data[i+1], b = data[i+2];
            data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
            data[i+1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
            data[i+2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
        } else if (type === 'brightness') {
             // Simple additive brightness
            data[i] = Math.min(255, Math.max(0, data[i] + val));
            data[i+1] = Math.min(255, Math.max(0, data[i+1] + val));
            data[i+2] = Math.min(255, Math.max(0, data[i+2] + val));
        } else if (type === 'hue') {
            // RGB to HSL, Shift H, HSL to RGB
            // Simplified approximation for demo speed
            // Proper impl needs RGB<->HSL conversion functions
            const [h, s, l] = rgbToHsl(data[i], data[i+1], data[i+2]);
            const newH = (h + val / 360) % 1;
            const [r, g, b] = hslToRgb(newH, s, l);
            data[i] = r; data[i+1] = g; data[i+2] = b;
        }
    }

    ctx.putImageData(imageData, 0, 0);
    historyManager.saveState();
    renderCanvas();
}

function applyConvolution(ctx, w, h, kernel, maskData) {
    const side = Math.round(Math.sqrt(kernel.length));
    const halfSide = Math.floor(side / 2);
    const srcData = ctx.getImageData(0, 0, w, h);
    const dstData = ctx.createImageData(w, h);
    const src = srcData.data;
    const dst = dstData.data;

    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            const dstOff = (y * w + x) * 4;

            // If masked out, copy original
            if (maskData && maskData[dstOff + 3] === 0) {
                dst[dstOff] = src[dstOff];
                dst[dstOff+1] = src[dstOff+1];
                dst[dstOff+2] = src[dstOff+2];
                dst[dstOff+3] = src[dstOff+3];
                continue;
            }

            let r = 0, g = 0, b = 0;
            for (let ky = 0; ky < side; ky++) {
                for (let kx = 0; kx < side; kx++) {
                    const scy = y + ky - halfSide;
                    const scx = x + kx - halfSide;
                    if (scy >= 0 && scy < h && scx >= 0 && scx < w) {
                        const srcOff = (scy * w + scx) * 4;
                        const wt = kernel[ky * side + kx];
                        r += src[srcOff] * wt;
                        g += src[srcOff + 1] * wt;
                        b += src[srcOff + 2] * wt;
                    }
                }
            }
            dst[dstOff] = r;
            dst[dstOff + 1] = g;
            dst[dstOff + 2] = b;
            dst[dstOff + 3] = src[dstOff + 3];
        }
    }
    ctx.putImageData(dstData, 0, 0);
}

// --- Histogram ---
function updateHistogram() {
    const canvas = document.getElementById('histogram-canvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;

    // Clear histogram
    ctx.clearRect(0, 0, w, h);

    // We want the histogram of the visible canvas.
    // However, mainCanvas is huge and might be transformed.
    // `renderCanvas` draws to `mainCtx`. But we might be mid-rendering.
    // To get accurate histogram of what user sees (the composition):
    // We need to access mainCtx pixel data.
    // But mainCtx has zoom/pan applied. `getImageData` is affected by backing store size, not transforms directly on returned array?
    // Actually getImageData gets pixels from the backing store.
    // Since we cleared and redrew everything on mainCanvas, its pixels are current composition.

    // Performance note: Reading 800x600 pixels every frame is heavy.
    // We should throttle this or do it only on idle/changes.
    // For this demo, we'll do it.

    // But `mainCanvas` might be huge if cropped larger?
    // And `getImageData` on hardware accel canvas can be slow.

    try {
        // Optimization: sample pixels? Or just do full.
        const imgData = mainCtx.getImageData(0, 0, mainCanvas.width, mainCanvas.height);
        const data = imgData.data;

        const rCounts = new Array(256).fill(0);
        const gCounts = new Array(256).fill(0);
        const bCounts = new Array(256).fill(0);

        let maxCount = 0;

        for (let i = 0; i < data.length; i += 4) {
            // Skip transparent pixels? Or count them? usually ignore alpha 0
            if (data[i+3] === 0) continue;

            rCounts[data[i]]++;
            gCounts[data[i+1]]++;
            bCounts[data[i+2]]++;
        }

        maxCount = Math.max(...rCounts, ...gCounts, ...bCounts);

        if (maxCount === 0) return;

        // Draw Histograms
        ctx.globalCompositeOperation = 'screen';

        // Draw Red
        ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
        drawChannel(ctx, w, h, rCounts, maxCount);

        // Draw Green
        ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
        drawChannel(ctx, w, h, gCounts, maxCount);

        // Draw Blue
        ctx.fillStyle = 'rgba(0, 0, 255, 0.5)';
        drawChannel(ctx, w, h, bCounts, maxCount);

        ctx.globalCompositeOperation = 'source-over';

    } catch (e) {
        // CORS issues if image imported from other domain?
        // Usually fine with file upload.
        console.error("Histogram error", e);
    }
}

function drawChannel(ctx, w, h, counts, max) {
    ctx.beginPath();
    ctx.moveTo(0, h);
    for (let i = 0; i < 256; i++) {
        const x = (i / 255) * w;
        const y = h - (counts[i] / max) * h;
        ctx.lineTo(x, y);
    }
    ctx.lineTo(w, h);
    ctx.closePath();
    ctx.fill();
}

// Helper: RGB <-> HSL
function rgbToHsl(r, g, b) {
    r /= 255, g /= 255, b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
        h = s = 0;
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return [h, s, l];
}

function hslToRgb(h, s, l) {
    let r, g, b;
    if (s === 0) {
        r = g = b = l;
    } else {
        const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }
    return [r * 255, g * 255, b * 255];
}

// --- Shortcuts ---
window.addEventListener('keydown', (e) => {
    if(e.code === 'Space') {
        isSpacePressed = true;
        mainCanvas.style.cursor = 'grab';
    }

    if(e.key === 'b') setTool('brush');
    if(e.key === 'e') setTool('eraser');
    if(e.key === 'g') setTool('fill');
    if(e.key === 'i') setTool('picker');
    if(e.key === 'c') setTool('crop');
    if(e.key === 'r') setTool('rect');
    // if(e.key === 'c') setTool('circle'); // Conflict with crop
    if(e.key === 'l') setTool('lasso');
    if(e.key === 't') setTool('text');
    if(e.key === 'm') setTool('marquee');
    if(e.key === 'v') setTool('move');
    if(e.key === 'Escape') selectionManager.clearSelection();
    if(e.key === '[' && brushSize > 1) { brushSize--; document.getElementById('brush-size').value = brushSize; }
    if(e.key === ']') { brushSize++; document.getElementById('brush-size').value = brushSize; }

    // Undo/Redo
    if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
        e.preventDefault();
        if (e.shiftKey) {
            historyManager.redo();
        } else {
            historyManager.undo();
        }
    }
    if ((e.ctrlKey || e.metaKey) && e.key === 'y') { // Windows standard redo
        e.preventDefault();
        historyManager.redo();
    }
});

window.addEventListener('keyup', (e) => {
    if(e.code === 'Space') {
        isSpacePressed = false;
        mainCanvas.style.cursor = getCursorForTool(currentTool);
        isPanning = false; // Stop panning if space released during drag
    }
});

// --- Menu Logic ---
function toggleMenu(menuId) {
    // Close other menus first
    const dropdowns = document.getElementsByClassName("dropdown-content");
    for (let i = 0; i < dropdowns.length; i++) {
        if (dropdowns[i].id !== menuId) {
            dropdowns[i].classList.remove('show');
        }
    }
    document.getElementById(menuId).classList.toggle("show");
}

function zoomIn() {
    zoomLevel *= 1.2;
    // Adjust pan to zoom towards center? Simple zoom center
    const cx = mainCanvas.width / 2;
    const cy = mainCanvas.height / 2;
    // panX = cx - (cx - panX) * 1.2;
    // panY = cy - (cy - panY) * 1.2;
    // Keeping it simple center zoom for menu click
    panX = panX * 1.2 - cx * 0.2;
    panY = panY * 1.2 - cy * 0.2;
    renderCanvas();
}

function zoomOut() {
    zoomLevel /= 1.2;
    const cx = mainCanvas.width / 2;
    const cy = mainCanvas.height / 2;
    panX = panX / 1.2 + cx * (1 - 1/1.2);
    panY = panY / 1.2 + cy * (1 - 1/1.2);
    renderCanvas();
}

function fitScreen() {
    zoomLevel = 1;
    panX = 0;
    panY = 0;
    renderCanvas();
}


// Close menus when clicking elsewhere
window.onclick = function(event) {
    if (!event.target.matches('.menu-item') && !event.target.matches('.menu-item *')) {
        const dropdowns = document.getElementsByClassName("dropdown-content");
        for (let i = 0; i < dropdowns.length; i++) {
            const openDropdown = dropdowns[i];
            if (openDropdown.classList.contains('show')) {
                openDropdown.classList.remove('show');
            }
        }
    }
}

// Initialize app
init();
    </script>
</body>
</html>
