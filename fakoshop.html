<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebPhoto Pro - Photoshop Clone</title>
    <style>
:root {
    --bg-dark: #2b2b2b;
    --bg-panel: #323232;
    --bg-tool: #4a4a4a;
    --text-main: #d9d9d9;
    --accent: #0078d7;
    --border: #1e1e1e;
}

* { box-sizing: border-box; user-select: none; }

body {
    margin: 0;
    padding: 0;
    background-color: var(--bg-dark);
    color: var(--text-main);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* Menu Bar */
#menubar {
    height: 30px;
    background-color: #1f1f1f;
    display: flex;
    align-items: center;
    padding: 0 10px;
    font-size: 13px;
    border-bottom: 1px solid #000;
}
.menu-item { padding: 5px 10px; cursor: pointer; position: relative; }
.menu-item:hover { background-color: var(--accent); color: white; }

.dropdown-content {
    display: none;
    position: absolute;
    top: 30px;
    left: 0;
    background-color: #2b2b2b;
    min-width: 160px;
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.5);
    z-index: 1000;
    border: 1px solid #1e1e1e;
}

.dropdown-content div {
    color: #d9d9d9;
    padding: 8px 16px;
    text-decoration: none;
    display: block;
    cursor: pointer;
}

.dropdown-content div:hover {
    background-color: var(--accent);
    color: white;
}

.dropdown-content hr {
    border: 0;
    border-top: 1px solid #444;
    margin: 4px 0;
}

.show { display: block; }

/* Main Workspace */
#workspace {
    display: flex;
    flex: 1;
    height: calc(100% - 30px);
}

/* Toolbar (Left) */
#toolbar {
    width: 40px;
    background-color: var(--bg-panel);
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    align-items: center;
    padding-top: 5px;
}
.tool {
    width: 32px;
    height: 32px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    margin-bottom: 2px;
    border-radius: 3px;
    font-size: 16px;
    color: #b0b0b0;
}
.tool:hover { background-color: var(--bg-tool); }
.tool.active { background-color: var(--bg-tool); border-left: 2px solid var(--accent); color: white; }

/* Options Bar (Top of Workspace) */
#options-bar {
    height: 35px;
    background-color: var(--bg-panel);
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    padding: 0 15px;
    gap: 15px;
    font-size: 12px;
}

/* Canvas Area (Center) */
#canvas-area {
    flex: 1;
    background-color: #1e1e1e;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: auto;
    position: relative;
}
#main-canvas {
    background-color: white;
    box-shadow: 0 0 20px rgba(0,0,0,0.5);
    cursor: crosshair;
}

/* Panels (Right) */
#panels {
    width: 200px;
    background-color: var(--bg-panel);
    border-left: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    resize: horizontal;
    overflow: auto;
    direction: rtl; /* Allows resize handle to appear on the left in RTL, though imperfect */
}
#panels > * {
    direction: ltr; /* Reset children to LTR */
}
.panel-header {
    padding: 8px 10px;
    background-color: #252525;
    font-size: 12px;
    font-weight: bold;
    border-bottom: 1px solid var(--border);
    border-top: 1px solid var(--border);
}
.panel-content { padding: 15px; }

/* Controls */
input[type="range"] { width: 100%; cursor: pointer; }
input[type="color"] { border: none; width: 30px; height: 30px; cursor: pointer; background: none; }
button {
    background-color: #4a4a4a; border: 1px solid #1e1e1e;
    color: white; padding: 5px 10px; cursor: pointer; width: 100%; margin-top: 5px; font-size: 11px;
}
button:hover { background-color: #5a5a5a; }

/* Layers Panel */
#layer-list {
    flex: 1;
    overflow-y: auto;
    background-color: #2b2b2b;
}
.layer-item {
    padding: 10px;
    border-bottom: 1px solid #383838;
    background-color: #323232;
    cursor: pointer;
    display: flex;
    align-items: center;
    font-size: 12px;
}
.layer-item.active { background-color: #454545; }
.layer-eye { margin-right: 10px; color: #aaa; cursor: pointer; }

/* Utility classes */
.hidden { display: none !important; }


/* Quick Actions Panels */
.action-btn {
    text-align: left;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.action-btn::after {
    content: '‚ñº';
    font-size: 8px;
    transition: transform 0.2s;
}
.action-btn.open::after {
    transform: rotate(180deg);
}

.action-sliders {
    display: flex;
    flex-direction: column;
    gap: 5px;
    padding: 10px;
    background-color: #2b2b2b;
    border: 1px solid #1e1e1e;
    border-top: none;
    font-size: 11px;
}
.action-sliders label {
    color: #ccc;
    margin-bottom: -2px;
}

/* Custom visual sliders */
.visual-slider {
    -webkit-appearance: none;
    width: 100%;
    height: 12px;
    border-radius: 6px;
    outline: none;
    margin: 5px 0 10px 0;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.5);
}
.visual-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: #fff;
    border: 2px solid #555;
    cursor: pointer;
    box-shadow: 0 1px 3px rgba(0,0,0,0.5);
}
.visual-slider::-moz-range-thumb {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: #fff;
    border: 2px solid #555;
    cursor: pointer;
    box-shadow: 0 1px 3px rgba(0,0,0,0.5);
}

/* Visual Tracks */
.hue-slider {
    background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);
}
.saturation-slider {
    background: linear-gradient(to right, #808080 0%, #0078d7 100%); /* Blue tint for saturation representation */
}
.brightness-slider {
    background: linear-gradient(to right, #000000 0%, #ffffff 100%);
}
.contrast-slider {
    background: linear-gradient(to right, #808080 0%, #000 50%, #fff 100%);
}
.blur-slider {
    background: linear-gradient(to right, #555 0%, #aaa 100%);
}
.levels-slider {
    background: linear-gradient(to right, #000 0%, #888 50%, #fff 100%);
}

/* Custom input styling for realism */
.input-group { margin-bottom: 10px; }
.input-label { display: block; margin-bottom: 5px; font-size: 11px; color: #aaa; }


@keyframes spin {
    to { transform: rotate(360deg); }
}

</style>
</head>
<body>

    <div id="menubar">
        <div class="menu-item" onclick="toggleMenu('file-menu')">File
            <div id="file-menu" class="dropdown-content">
                <div onclick="newFile()">New</div>
                <div onclick="document.getElementById('file-upload').click()">Open Image...</div>
                <div onclick="document.getElementById('project-upload').click()">Open Project...</div>
                <hr>
                <div onclick="saveProject()">Save Project</div>
                <div onclick="downloadImage()">Export as JPG</div>
            </div>
        </div>
        <div class="menu-item" onclick="toggleMenu('edit-menu')">Edit
            <div id="edit-menu" class="dropdown-content">
                <div onclick="historyManager.undo()">Undo (Ctrl+Z)</div>
                <div onclick="historyManager.redo()">Redo (Ctrl+Y)</div>
                <hr>
                <div onclick="transformLayer('scale')">Scale Layer...</div>
                <div onclick="transformLayer('rotate')">Rotate Layer...</div>
                <div onclick="applyLayerStyle('shadow')">Drop Shadow...</div>
                <hr>
                <div onclick="alert('Cut/Copy/Paste not implemented (requires permissions)')">Cut</div>
                <div onclick="alert('Cut/Copy/Paste not implemented (requires permissions)')">Copy</div>
                <div onclick="alert('Cut/Copy/Paste not implemented (requires permissions)')">Paste</div>
            </div>
        </div>
        <div class="menu-item" onclick="toggleMenu('image-menu')">Image
            <div id="image-menu" class="dropdown-content">
                <div onclick="applyImageAdjustment('brightness')">Brightness/Contrast...</div>
                <div onclick="applyImageAdjustment('hue')">Hue/Saturation...</div>
                <div onclick="applyImageAdjustment('invert')">Invert</div>
            </div>
        </div>
        <div class="menu-item" onclick="toggleMenu('filter-menu')">Filter
            <div id="filter-menu" class="dropdown-content">
                <div onclick="applyImageAdjustment('blur')">Gaussian Blur...</div>
                <div onclick="applyImageAdjustment('sharpen')">Sharpen</div>
                <div onclick="applyImageAdjustment('emboss')">Emboss</div>
                <div onclick="applyImageAdjustment('pixelate')">Pixelate...</div>
                <div onclick="applyImageAdjustment('noise')">Add Noise...</div>
                <div onclick="applyImageAdjustment('vignette')">Vignette...</div>
                <hr>
                <div onclick="applyImageAdjustment('grayscale')">Grayscale</div>
                <div onclick="applyImageAdjustment('sepia')">Sepia</div>
            </div>
        </div>
        <div class="menu-item" onclick="toggleMenu('view-menu')">View
            <div id="view-menu" class="dropdown-content">
                <div onclick="zoomIn()">Zoom In</div>
                <div onclick="zoomOut()">Zoom Out</div>
                <div onclick="fitScreen()">Fit Screen</div>
            </div>
        </div>
        <div class="menu-item" onclick="toggleMenu('window-menu')">Window
            <div id="window-menu" class="dropdown-content">
                <div onclick="document.getElementById('panels').classList.toggle('hidden')">Toggle Panels</div>
            </div>
        </div>
        <div class="menu-item" onclick="toggleMenu('help-menu')">Help
            <div id="help-menu" class="dropdown-content">
                <div onclick="alert('WebPhoto Pro v1.0\nSimulated Photoshop Clone')">About</div>
            </div>
        </div>
    </div>

    <div id="workspace">

        <div id="toolbar">
            <div class="tool active" title="Brush Tool (B)" onclick="setTool('brush')">üñåÔ∏è</div>
            <div class="tool" title="Spray Can" onclick="setTool('spray')">üí®</div>
            <div class="tool" title="Watercolor" onclick="setTool('watercolor')">üñåÔ∏è</div>
            <div class="tool" title="Marker" onclick="setTool('marker')">üñçÔ∏è</div>
            <div class="tool" title="Pencil" onclick="setTool('pencil')">‚úèÔ∏è</div>

            <div class="tool" title="Eraser Tool (E)" onclick="setTool('eraser')">üßº</div>
            <div class="tool" title="Clone Stamp (S)" onclick="setTool('clone')">¬©</div>
            <div class="tool" title="Smudge Tool" onclick="setTool('smudge')">üëÜ</div>
            <div class="tool" title="Blur Tool" onclick="setTool('blur-brush')">üíß</div>
            <div class="tool" title="Sharpen Tool" onclick="setTool('sharpen-brush')">üî∫</div>
            <div class="tool" title="Dodge Tool" onclick="setTool('dodge')">üí°</div>
            <div class="tool" title="Burn Tool" onclick="setTool('burn')">üî•</div>
            <div class="tool" title="Move Tool (V)" onclick="setTool('move')">‚ú•</div>
            <div class="tool" title="Fill Bucket (G)" onclick="setTool('fill')">ü™£</div>
            <div class="tool" title="Gradient (Shift+G)" onclick="setTool('gradient')">üåà</div>
            <div class="tool" title="Magic Wand (W)" onclick="setTool('wand')">ü™Ñ</div>
            <div class="tool" title="Eyedropper (I)" onclick="setTool('picker')">üñäÔ∏è</div>
            <div class="tool" title="Crop Tool (C)" onclick="setTool('crop')">‚úÇÔ∏è</div>
            <div class="tool" title="Rectangle (R)" onclick="setTool('rect')">‚¨ú</div>
            <div class="tool" title="Circle (C)" onclick="setTool('circle')">‚≠ï</div>
            <div class="tool" title="Line (L)" onclick="setTool('line')">üìè</div>
            <div class="tool" title="Text (T)" onclick="setTool('text')">TXT</div>
            <div class="tool" title="Marquee Select (M)" onclick="setTool('marquee')">‚öÉ</div>
            <div class="tool" title="Lasso Select (L)" onclick="setTool('lasso')">‚û∞</div>
            <div class="tool" title="Polygon Lasso (P)" onclick="setTool('poly-lasso')">üìê</div>
            <div class="tool" title="Pen Tool (P)" onclick="setTool('pen')">üñãÔ∏è</div>
            <div class="tool" title="Polygon Shape" onclick="setTool('polygon')">‚¨†</div>
            <div class="tool" title="Star Shape" onclick="setTool('star')">‚≠ê</div>
            <div class="tool" title="Rounded Rectangle" onclick="setTool('rounded-rect')">‚ñ¢</div>
            <div class="tool" title="Clear Selection (Esc)" onclick="selectionManager.clearSelection()">‚úñ</div>
            <div style="flex:1"></div>

            <div id="color-history" style="display:flex; flex-wrap:wrap; width:32px; justify-content:center; gap:2px; margin-bottom:5px;">
                <!-- History colors injected here -->
            </div>

            <div style="display:flex; flex-direction:column; align-items:center; gap:2px; margin-bottom:5px;">
                <input type="color" id="primary-color" value="#000000" title="Primary Color" style="width:20px; height:20px;">
                <input type="color" id="secondary-color" value="#ffffff" title="Secondary Color" style="width:20px; height:20px;">
            </div>
        </div>

        <div style="flex: 1; display: flex; flex-direction: column;">
            <div id="options-bar">
                <span>Size:</span>
                <input type="range" id="brush-size" min="1" max="100" value="10" style="width: 100px;">
                <span id="brush-size-val">10px</span>

                <span style="margin-left: 10px;">Opacity:</span>
                <input type="range" id="brush-opacity" min="1" max="100" value="100" style="width: 100px;">
                <span id="brush-opacity-val">100%</span>

                <span style="margin-left: 10px;">Hardness:</span>
                <input type="range" id="brush-hardness" min="0" max="100" value="100" style="width: 100px;">
                <span id="brush-hardness-val">100%</span>

                <select id="brush-type" style="margin-left: 10px; padding: 2px;">
                    <option value="round">Round</option>
                    <option value="square">Square</option>
                    <option value="calligraphy">Calligraphy</option>
                </select>

                <label style="margin-left: 10px; display: flex; align-items: center; gap: 5px;">
                    <input type="checkbox" id="airbrush-toggle"> Airbrush
                </label>

                <div id="shape-options" style="display: none; margin-left: 10px; align-items: center; gap: 10px;">
                     <label><input type="checkbox" id="shape-fill" checked> Fill</label>
                     <label><input type="checkbox" id="shape-stroke"> Stroke</label>
                     <div id="extra-shape-options" style="display: none; align-items: center; gap: 5px; margin-left: 5px;">
                         <span id="sides-label">Sides/Points:</span>
                         <input type="number" id="shape-sides" value="5" min="3" max="20" style="width: 40px;">
                         <span id="radius-label" style="display: none;">Radius:</span>
                         <input type="number" id="shape-radius" value="10" min="0" max="100" style="width: 40px; display: none;">
                     </div>
                </div>

                <div id="text-options" style="display: none; margin-left: 10px; align-items: center; gap: 5px;">
                    <select id="font-family" style="padding: 2px;">
                        <option value="Arial">Arial</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Comic Sans MS">Comic Sans MS</option>
                    </select>
                    <label><input type="checkbox" id="font-bold"> B</label>
                    <label><input type="checkbox" id="font-italic"> I</label>
                </div>

                <div id="wand-options" style="display: none; margin-left: 10px; align-items: center; gap: 5px;">
                    <span>Tol:</span>
                    <input type="number" id="wand-tolerance" value="30" min="0" max="255" style="width: 50px;">
                </div>

                <div id="spray-options" style="display: none; margin-left: 10px; align-items: center; gap: 5px;">
                    <select id="spray-type" style="padding: 2px;">
                        <option value="scatter">Scattered Dots</option>
                        <option value="soft">Soft Radial</option>
                        <option value="wide">Wide Nozzle</option>
                        <option value="thin">Thin Nozzle</option>
                    </select>
                </div>


                                <span style="margin-left: auto;">Smoothing:</span>
                <input type="range" id="brush-smoothing" min="0" max="100" value="10" style="width: 100px;">
                <span id="brush-smoothing-val">10%</span>
            </div>

            <div id="ai-tools-bar" style="height: 35px; background-color: var(--bg-panel); border-bottom: 1px solid var(--border); display: flex; align-items: center; padding: 0 15px; gap: 10px; font-size: 11px;">
                <span style="color: #a0a0ff; font-weight: bold; margin-right: 5px;">‚ú® AI Tools:</span>
                <button onclick="aiSimulate('fill')" style="width: auto; margin: 0; padding: 3px 8px;" title="Fills selection with AI generated content">Generative Fill</button>
                <button onclick="aiSimulate('bg-remove')" style="width: auto; margin: 0; padding: 3px 8px;" title="Removes background from current layer">Remove Background</button>
                <button onclick="aiSimulate('upscale')" style="width: auto; margin: 0; padding: 3px 8px;" title="Upscales canvas 2x">Upscale 2x</button>
                <button onclick="aiSimulate('style')" style="width: auto; margin: 0; padding: 3px 8px;" title="Applies a stylized artistic filter">Style Transfer</button>
                <button onclick="aiSimulate('txt2img')" style="width: auto; margin: 0; padding: 3px 8px;" title="Generates image from text">Text to Image</button>

                <div id="ai-loading" style="display: none; align-items: center; gap: 5px; margin-left: auto; color: #a0a0ff; font-weight: bold;">
                    <span class="spinner" style="display: inline-block; width: 12px; height: 12px; border: 2px solid rgba(160,160,255,0.3); border-radius: 50%; border-top-color: #a0a0ff; animation: spin 1s ease-in-out infinite;"></span>
                    Processing AI...
                </div>
            </div>

            <div id="canvas-area">
                <canvas id="main-canvas" width="800" height="600"></canvas>
            </div>
        </div>

        <div id="panels">

            <div class="panel-header">Navigator & Info</div>
            <div class="panel-content" style="height: 150px; display:flex; justify-content:center; align-items:center; color:#555; padding: 0;">
                <canvas id="histogram-canvas" width="260" height="150" style="width: 100%; height: 100%; background: #222;"></canvas>
            </div>

            <div class="panel-header">Quick Actions</div>
            <div class="panel-content" id="quick-actions-panel" style="display: flex; flex-direction: column; gap: 8px;">
                <div class="action-group">
                    <button class="action-btn" onclick="toggleActionGroup('brightness-group')">Brightness / Contrast</button>
                    <div id="brightness-group" class="action-sliders hidden">
                        <label>Brightness</label>
                        <input type="range" class="visual-slider brightness-slider" id="slider-brightness" min="-100" max="100" value="0" oninput="previewAdjustment()" onchange="commitAdjustment()">
                        <label>Contrast</label>
                        <input type="range" class="visual-slider contrast-slider" id="slider-contrast" min="-100" max="100" value="0" oninput="previewAdjustment()" onchange="commitAdjustment()">
                    </div>
                </div>

                <div class="action-group">
                    <button class="action-btn" onclick="toggleActionGroup('hue-group')">Hue / Saturation</button>
                    <div id="hue-group" class="action-sliders hidden">
                        <label>Hue</label>
                        <input type="range" class="visual-slider hue-slider" id="slider-hue" min="-180" max="180" value="0" oninput="previewAdjustment()" onchange="commitAdjustment()">
                        <label>Saturation</label>
                        <input type="range" class="visual-slider saturation-slider" id="slider-saturation" min="-100" max="100" value="0" oninput="previewAdjustment()" onchange="commitAdjustment()">
                    </div>
                </div>

                <div class="action-group">
                    <button class="action-btn" onclick="toggleActionGroup('blur-group')">Blur</button>
                    <div id="blur-group" class="action-sliders hidden">
                        <label>Radius</label>
                        <input type="range" class="visual-slider blur-slider" id="slider-blur" min="0" max="20" value="0" step="0.5" oninput="previewAdjustment()" onchange="commitAdjustment()">
                    </div>
                </div>

                <div class="action-group">
                    <button class="action-btn" onclick="toggleActionGroup('levels-group')">Levels (Gamma)</button>
                    <div id="levels-group" class="action-sliders hidden">
                        <label>Midtones</label>
                        <input type="range" class="visual-slider levels-slider" id="slider-levels" min="0.1" max="9.9" value="1.0" step="0.1" oninput="previewAdjustment()" onchange="commitAdjustment()">
                    </div>
                </div>

                <button onclick="applyImageAdjustment('invert')">Invert</button>
                <hr style="border: 0; border-top: 1px solid #444; margin: 10px 0;">
                <input type="file" id="file-upload" style="display: none;" onchange="handleFileUpload(this)">
                <input type="file" id="project-upload" style="display: none;" accept=".json" onchange="loadProject(this)">
                <button onclick="document.getElementById('file-upload').click()">Open Image</button>
            </div>

            <div class="panel-header">Layers</div>
            <div class="panel-content" style="padding: 5px;">
                <select id="blend-mode" onchange="layerManager.setBlendMode(this.value)" style="width:100%; margin-bottom:5px;">
                    <option value="source-over">Normal</option>
                    <option value="multiply">Multiply</option>
                    <option value="screen">Screen</option>
                    <option value="overlay">Overlay</option>
                    <option value="darken">Darken</option>
                    <option value="lighten">Lighten</option>
                    <option value="color-dodge">Color Dodge</option>
                    <option value="color-burn">Color Burn</option>
                    <option value="hard-light">Hard Light</option>
                    <option value="soft-light">Soft Light</option>
                    <option value="difference">Difference</option>
                    <option value="exclusion">Exclusion</option>
                </select>
                <div class="input-group">
                    <span class="input-label">Layer Opacity</span>
                    <input type="range" min="0" max="1" step="0.01" value="1" onchange="layerManager.setOpacity(this.value)">
                </div>
            </div>
            <div id="layer-list">
                <!-- Layer items populated by JS -->
            </div>
            <div class="panel-header" style="border-top:none; display:flex; justify-content:flex-end;">
                <span style="cursor:pointer; padding:0 5px;" title="New Layer Mask" onclick="layerManager.addMaskToActive()">‚¨ú</span>
                <span style="cursor:pointer; padding:0 5px;" title="New Layer" onclick="layerManager.addLayer()">üìÑ +</span>
                <span style="cursor:pointer; padding:0 5px;" title="Duplicate Layer" onclick="layerManager.duplicateActiveLayer()">üìÑ ¬≤</span>
                <span style="cursor:pointer; padding:0 5px;" title="Merge Down" onclick="layerManager.mergeDown()">‚è¨</span>
                <span style="cursor:pointer; padding:0 5px;" title="Delete Layer" onclick="layerManager.deleteActiveLayer()">üóëÔ∏è</span>
                <span style="cursor:pointer; padding:0 5px;" title="Move Up" onclick="layerManager.moveLayer(1)">‚¨ÜÔ∏è</span>
                <span style="cursor:pointer; padding:0 5px;" title="Move Down" onclick="layerManager.moveLayer(-1)">‚¨áÔ∏è</span>
            </div>

        </div>
    </div>

    <script>
// --- Layer System ---
class Layer {
    constructor(id, name, width, height) {
        this.id = id;
        this.name = name;
        this.visible = true;
        this.opacity = 1.0;
        this.blendMode = 'source-over';
        this.x = 0;
        this.y = 0;
        this.scaleX = 1;
        this.scaleY = 1;
        this.rotation = 0; // in radians

        // Mask
        this.maskCanvas = null;
        this.maskCtx = null;
        this.editingMask = false;

        // Off-screen canvas for this layer
        this.canvas = document.createElement('canvas');
        this.canvas.width = width;
        this.canvas.height = height;
        this.ctx = this.canvas.getContext('2d');
    }

    clear() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

class LayerManager {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this.layers = [];
        this.activeLayerId = null;
        this.layerCounter = 0;
    }

    addLayer(name = null) {
        this.layerCounter++;
        // Ensure unique name if auto-generated
        let newName = name || `Layer ${this.layerCounter}`;

        const layer = new Layer(this.layerCounter, newName, this.width, this.height);

        // Add to top of stack
        this.layers.push(layer);
        this.activeLayerId = layer.id;

        renderLayerList();
        renderCanvas();
        return layer;
    }

    getActiveLayer() {
        return this.layers.find(l => l.id === this.activeLayerId);
    }

    deleteActiveLayer() {
        if (this.layers.length <= 1) {
            alert("Cannot delete the last layer.");
            return;
        }
        const index = this.layers.findIndex(l => l.id === this.activeLayerId);

        // Prevent deleting if it's the only layer (redundant check but safe)
        if (index === -1) return;

        this.layers.splice(index, 1);

        // Set new active layer to the one below, or above if it was the bottom
        const newIndex = Math.max(0, index - 1);
        this.activeLayerId = this.layers[newIndex].id;

        renderLayerList();
        renderCanvas();
    }

    moveLayer(direction) { // -1 down, 1 up
        const index = this.layers.findIndex(l => l.id === this.activeLayerId);
        if (direction === -1 && index > 0) {
            [this.layers[index], this.layers[index - 1]] = [this.layers[index - 1], this.layers[index]];
        } else if (direction === 1 && index < this.layers.length - 1) {
            [this.layers[index], this.layers[index + 1]] = [this.layers[index + 1], this.layers[index]];
        }
        renderLayerList();
        renderCanvas();
    }

    toggleVisibility(id) {
        const layer = this.layers.find(l => l.id === id);
        if(layer) {
            layer.visible = !layer.visible;
            renderLayerList();
            renderCanvas();
        }
    }

    setBlendMode(mode) {
        const layer = this.getActiveLayer();
        if(layer) {
            layer.blendMode = mode;
            renderCanvas();
        }
    }

    setOpacity(value) {
        const layer = this.getActiveLayer();
        if(layer) {
            layer.opacity = value;
            renderCanvas();
        }
    }

    duplicateActiveLayer() {
        const layer = this.getActiveLayer();
        if (!layer) return;

        const newLayer = this.addLayer(layer.name + " Copy");
        // Copy properties
        newLayer.x = layer.x;
        newLayer.y = layer.y;
        newLayer.scaleX = layer.scaleX;
        newLayer.scaleY = layer.scaleY;
        newLayer.rotation = layer.rotation;
        newLayer.opacity = layer.opacity;
        newLayer.blendMode = layer.blendMode;

        // Copy content
        newLayer.ctx.drawImage(layer.canvas, 0, 0);

        renderCanvas();
        historyManager.saveState();
    }

    mergeDown() {
        const index = this.layers.findIndex(l => l.id === this.activeLayerId);
        if (index <= 0) {
            alert("No layer below to merge into.");
            return;
        }

        const topLayer = this.layers[index];
        const bottomLayer = this.layers[index - 1];

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = this.width;
        tempCanvas.height = this.height;
        const ctx = tempCanvas.getContext('2d');

        // Draw Bottom
        if(bottomLayer.visible) {
            ctx.save();
            ctx.globalAlpha = bottomLayer.opacity;
            // No blend mode for bottom, it's the base of the merge

            const cx1 = (bottomLayer.x || 0) + bottomLayer.canvas.width / 2;
            const cy1 = (bottomLayer.y || 0) + bottomLayer.canvas.height / 2;
            ctx.translate(cx1, cy1);
            ctx.rotate(bottomLayer.rotation || 0);
            ctx.scale(bottomLayer.scaleX || 1, bottomLayer.scaleY || 1);
            ctx.translate(-cx1, -cy1);
            ctx.drawImage(bottomLayer.canvas, bottomLayer.x || 0, bottomLayer.y || 0);
            ctx.restore();
        }

        // Draw Top
        if(topLayer.visible) {
            ctx.save();
            ctx.globalAlpha = topLayer.opacity;
            ctx.globalCompositeOperation = topLayer.blendMode;

            const cx2 = (topLayer.x || 0) + topLayer.canvas.width / 2;
            const cy2 = (topLayer.y || 0) + topLayer.canvas.height / 2;
            ctx.translate(cx2, cy2);
            ctx.rotate(topLayer.rotation || 0);
            ctx.scale(topLayer.scaleX || 1, topLayer.scaleY || 1);
            ctx.translate(-cx2, -cy2);
            ctx.drawImage(topLayer.canvas, topLayer.x || 0, topLayer.y || 0);
            ctx.restore();
        }

        // Update Bottom Layer
        bottomLayer.ctx.clearRect(0,0, bottomLayer.canvas.width, bottomLayer.canvas.height);
        bottomLayer.ctx.drawImage(tempCanvas, 0, 0); // Copy merged result

        // Reset Bottom Layer Properties (it is now a rasterized composition)
        bottomLayer.x = 0;
        bottomLayer.y = 0;
        bottomLayer.rotation = 0;
        bottomLayer.scaleX = 1;
        bottomLayer.scaleY = 1;
        bottomLayer.opacity = 1;
        bottomLayer.blendMode = 'source-over';

        // Remove Top Layer
        this.layers.splice(index, 1);
        this.activeLayerId = bottomLayer.id;

        renderLayerList();
        renderCanvas();
        historyManager.saveState();
    }
}

// --- History System ---
class HistoryManager {
    constructor(limit = 20) {
        this.limit = limit;
        this.stack = [];
        this.pointer = -1;
    }

    saveState() {
        // Remove redo states if we are in the middle of the stack
        if (this.pointer < this.stack.length - 1) {
            this.stack = this.stack.slice(0, this.pointer + 1);
        }

        // Deep copy the current state of all layers
        const state = layerManager.layers.map(layer => {
            const newCanvas = document.createElement('canvas');
            newCanvas.width = layer.canvas.width;
            newCanvas.height = layer.canvas.height;
            newCanvas.getContext('2d').drawImage(layer.canvas, 0, 0);

            return {
                id: layer.id,
                name: layer.name,
                visible: layer.visible,
                opacity: layer.opacity,
                blendMode: layer.blendMode,
                x: layer.x,
                y: layer.y,
                scaleX: layer.scaleX || 1,
                scaleY: layer.scaleY || 1,
                rotation: layer.rotation || 0,
                canvas: newCanvas
            };
        });

        const fullState = {
            layers: state,
            activeLayerId: layerManager.activeLayerId,
            layerCounter: layerManager.layerCounter,
            // Also save canvas dimensions for crop undo
            width: layerManager.width,
            height: layerManager.height
        };

        this.stack.push(fullState);

        // Enforce limit
        if (this.stack.length > this.limit) {
            this.stack.shift();
        } else {
            this.pointer++;
        }

        console.log("State saved. Pointer:", this.pointer);
    }

    undo() {
        if (this.pointer > 0) {
            this.pointer--;
            this.restoreState(this.stack[this.pointer]);
        }
    }

    redo() {
        if (this.pointer < this.stack.length - 1) {
            this.pointer++;
            this.restoreState(this.stack[this.pointer]);
        }
    }

    restoreState(state) {
        // Restore dimensions if changed (e.g. crop)
        if (state.width !== layerManager.width || state.height !== layerManager.height) {
            mainCanvas.width = state.width;
            mainCanvas.height = state.height;
            layerManager.width = state.width;
            layerManager.height = state.height;
            selectionManager.width = state.width;
            selectionManager.height = state.height;
            selectionManager.maskCanvas.width = state.width;
            selectionManager.maskCanvas.height = state.height;
        }

        // Restore LayerManager state
        layerManager.activeLayerId = state.activeLayerId;
        layerManager.layerCounter = state.layerCounter;

        // Reconstruct layers
        layerManager.layers = state.layers.map(lData => {
            const layer = new Layer(lData.id, lData.name, lData.canvas.width, lData.canvas.height);
            layer.visible = lData.visible;
            layer.opacity = lData.opacity;
            layer.blendMode = lData.blendMode;
            layer.x = lData.x || 0;
            layer.y = lData.y || 0;
            layer.scaleX = lData.scaleX || 1;
            layer.scaleY = lData.scaleY || 1;
            layer.rotation = lData.rotation || 0;
            layer.ctx.drawImage(lData.canvas, 0, 0);
            return layer;
        });

        renderLayerList();
        renderCanvas();
        console.log("State restored. Pointer:", this.pointer);
    }
}

// --- Selection System ---
class SelectionManager {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this.hasSelection = false;

        // Mask canvas: white = selected, black/transparent = unselected
        this.maskCanvas = document.createElement('canvas');
        this.maskCanvas.width = width;
        this.maskCanvas.height = height;
        this.ctx = this.maskCanvas.getContext('2d');

        // Path storage for lasso
        this.currentPath = [];
    }

    clearSelection() {
        this.ctx.clearRect(0, 0, this.width, this.height);
        this.hasSelection = false;
        renderCanvas();
    }

    startSelection(x, y) {
        this.clearSelection();
        this.hasSelection = true;
        this.startX = x;
        this.startY = y;

        if (currentTool === 'lasso') {
            this.ctx.beginPath();
            this.ctx.moveTo(x, y);
            this.currentPath = [[x, y]];
        }
    }

    updateSelection(x, y) {
        if (!this.hasSelection) return;
        this.lastX = x;
        this.lastY = y;

        if (currentTool === 'marquee' || currentTool === 'crop') {
            this.ctx.clearRect(0, 0, this.width, this.height);
            this.ctx.fillStyle = 'rgba(0,0,0,1)'; // Use solid color for mask logic
            this.ctx.fillRect(this.startX, this.startY, x - this.startX, y - this.startY);
        } else if (currentTool === 'lasso') {
            this.ctx.lineTo(x, y);
            this.ctx.stroke();
            this.currentPath.push([x, y]);
        }

        renderCanvas();
    }

    endSelection(x, y) {
        if (currentTool === 'lasso') {
            this.ctx.clearRect(0, 0, this.width, this.height);
            this.ctx.beginPath();
            if (this.currentPath.length > 0) {
                this.ctx.moveTo(this.currentPath[0][0], this.currentPath[0][1]);
                for(let p of this.currentPath) this.ctx.lineTo(p[0], p[1]);
            }
            this.ctx.closePath();
            this.ctx.fillStyle = 'rgba(0,0,0,1)';
            this.ctx.fill();
        }
        renderCanvas();
    }

    // Apply clipping to a context based on selection
    clipContext(ctx, inverse = false, layerX = 0, layerY = 0) {
        if (!this.hasSelection) return;
        ctx.globalCompositeOperation = 'destination-in';
        ctx.drawImage(this.maskCanvas, -layerX, -layerY);
        ctx.globalCompositeOperation = 'source-over';
    }
    applyClip(ctx, layerX = 0, layerY = 0) {
        if (!this.hasSelection) return;
        ctx.beginPath();
        if (currentTool === 'marquee' || currentTool === 'crop') {
            const w = (this.lastX || this.startX) - this.startX;
            const h = (this.lastY || this.startY) - this.startY;
            ctx.rect(this.startX - layerX, this.startY - layerY, w, h);
        } else if (currentTool === 'lasso' && this.currentPath.length > 0) {
            ctx.moveTo(this.currentPath[0][0] - layerX, this.currentPath[0][1] - layerY);
            for (let i = 1; i < this.currentPath.length; i++) {
                ctx.lineTo(this.currentPath[i][0] - layerX, this.currentPath[i][1] - layerY);
            }
            ctx.closePath();
        } else if (currentTool === 'wand') {
            // Wand is a raster mask, we CANNOT use `ctx.clip()` with paths.
            // Oh right, wand selection creates raster pixels, not paths.
            // In that case, we must use `globalCompositeOperation = 'destination-in'` with the maskCanvas.
        }

        if (currentTool !== 'wand') {
             ctx.clip();
        }
    }

}

// --- Core Variables ---
const mainCanvas = document.getElementById('main-canvas');
const mainCtx = mainCanvas.getContext('2d');
const layerManager = new LayerManager(mainCanvas.width, mainCanvas.height);
const historyManager = new HistoryManager();
const selectionManager = new SelectionManager(mainCanvas.width, mainCanvas.height);

let painting = false;
let airbrushInterval = null;
let currentTool = 'brush';
let brushSize = 10;
let brushColor = '#000000';
let secondaryColor = '#ffffff';
let activeColor = '#000000';
let brushOpacity = 1;
let brushHardness = 100;
let brushSmoothing = 10; // Smoothing factor (0-100)
let smoothedX, smoothedY; // Tracking the smoothed brush tip
let brushType = 'round'; // round, square, calligraphy
let isAirbrush = false;
let shapeFill = true;
let shapeStroke = false;
let fontFamily = 'Arial';
let fontBold = false;
let fontItalic = false;
let wandTolerance = 30;
let sprayType = 'scatter';
let polygonPoints = []; // For Polygon Lasso
let penPath = []; // For Pen Tool [{x, y, type: 'M'|'L'|'Q'|'C', cp1x, cp1y, cp2x, cp2y}]
let isDraggingPen = false;
let colorHistory = [];
let startX, startY; // For shape tools

// Zoom & Pan Variables
let zoomLevel = 1.0;
let panX = 0;
let panY = 0;
let isPanning = false;
let isSpacePressed = false;
let lastPanX, lastPanY;
let lastMoveX, lastMoveY; // For move tool

// Clone Stamp
let cloneSourceX = null;
let cloneSourceY = null;

// --- Initialization ---
function init() {
    // Maximize Canvas Logic
    // We want the canvas to fill the available space in #canvas-area on load
    const canvasArea = document.getElementById('canvas-area');
    const w = canvasArea.clientWidth;
    const h = canvasArea.clientHeight;

    // Update main canvas and manager dimensions
    mainCanvas.width = w;
    mainCanvas.height = h;
    layerManager.width = w;
    layerManager.height = h;
    selectionManager.width = w;
    selectionManager.height = h;
    selectionManager.maskCanvas.width = w;
    selectionManager.maskCanvas.height = h;

    // Create background layer
    const bg = layerManager.addLayer('Background');
    bg.ctx.fillStyle = '#ffffff';
    bg.ctx.fillRect(0, 0, bg.canvas.width, bg.canvas.height);

    // Save initial state
    historyManager.saveState();

    renderLayerList();
    renderCanvas();

    // Handle Window Resize (optional but good for UX)
    window.addEventListener('resize', handleResize);
}

function handleResize() {
    // Note: Standard image editors do NOT resize the image document on window resize.
    // They usually just center/zoom the view.
    // However, the user asked to "maximize use of screen".
    // For this prototype, we won't destructively resize the active document on window resize,
    // as that would crop/distort user work.
    // We will just let the CSS handle the view container size.
    // The "maximize" happened on init.
}

function renderCanvas() {
    // Clear main display canvas
    mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);

    mainCtx.save(); // Save context state before applying transforms

    // Apply Pan and Zoom
    mainCtx.translate(panX, panY);
    mainCtx.scale(zoomLevel, zoomLevel);

    // Draw pattern background (checkerboard for transparency)
    drawCheckerboard(mainCtx, mainCanvas.width, mainCanvas.height);

    // Composite layers
    layerManager.layers.forEach(layer => {
        if (!layer.visible) return;

        mainCtx.save();
        mainCtx.globalAlpha = layer.opacity;
        mainCtx.globalCompositeOperation = layer.blendMode;

        // Apply layer transformations (Translate -> Rotate -> Scale)

        // Translate to layer position
        const centerX = (layer.x || 0) + layer.canvas.width / 2;
        const centerY = (layer.y || 0) + layer.canvas.height / 2;

        mainCtx.translate(centerX, centerY);
        mainCtx.rotate(layer.rotation || 0);
        mainCtx.scale(layer.scaleX || 1, layer.scaleY || 1);
        mainCtx.translate(-centerX, -centerY);

        if (layer.maskCanvas) {
            // To apply mask, we need to draw the layer to a temporary canvas,
            // apply the mask using destination-in, and then draw the result.
            // This is because we might also have transformations on the layer.
            const tCanvas = document.createElement('canvas');
            tCanvas.width = layer.canvas.width;
            tCanvas.height = layer.canvas.height;
            const tCtx = tCanvas.getContext('2d');

            tCtx.drawImage(layer.canvas, 0, 0);
            tCtx.globalCompositeOperation = 'destination-in';
            // Draw mask using luminance or just alpha. Since we use b/w for masks usually,
            // standard canvas destination-in uses alpha channel.
            // If the user paints with black, it should create transparency.
            // We need to convert mask luminance to alpha.
            // Better: When user paints on mask, we ensure they only affect alpha or we process the mask here.
            // For simplicity, let's assume the user paints directly with rgba(0,0,0,alpha) to erase.
            tCtx.drawImage(layer.maskCanvas, 0, 0);

            mainCtx.drawImage(tCanvas, layer.x || 0, layer.y || 0);
        } else {
            mainCtx.drawImage(layer.canvas, layer.x || 0, layer.y || 0);
        }

        mainCtx.restore();
    });

    // Reset context state for overlay drawing (Selection/Crop)
    mainCtx.globalAlpha = 1.0;
    mainCtx.globalCompositeOperation = 'source-over';

    // Draw Selection Outline
    if (selectionManager.hasSelection) {
        mainCtx.save();
        mainCtx.lineWidth = 1 / zoomLevel;
        mainCtx.setLineDash([4 / zoomLevel, 4 / zoomLevel]);

        if (currentTool === 'crop') {
            // Darken area outside crop
            mainCtx.fillStyle = 'rgba(0,0,0,0.5)';
            mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);

            // Clear the selection part to reveal image (or just draw selection border)
            // Composite destination-out to clear hole?
            mainCtx.globalCompositeOperation = 'destination-out';
            mainCtx.drawImage(selectionManager.maskCanvas, 0, 0);

            // Draw crop border
            mainCtx.globalCompositeOperation = 'source-over';
            mainCtx.strokeStyle = '#fff';
            mainCtx.strokeRect(selectionManager.startX, selectionManager.startY,
                              (window.lastMouseX || selectionManager.startX) - selectionManager.startX,
                              (window.lastMouseY || selectionManager.startY) - selectionManager.startY); // Approximation, relies on updateSelection

            // Since `maskCanvas` contains the rect, we can just outline it if simple
            // But for live drag, updateSelection logic handles rendering to maskCanvas
            // We need to outline the non-transparent part of maskCanvas?

            // Better: updateSelection already fills maskCanvas.
            // We just need to visualize it nicely for Crop.
        } else {
            mainCtx.strokeStyle = '#000';
            mainCtx.globalAlpha = 0.2;
            mainCtx.fillStyle = '#00f';
            mainCtx.drawImage(selectionManager.maskCanvas, 0, 0);
        }

        mainCtx.restore();
    }

    // Draw Preview for shapes (if painting)
    if (painting && ['rect', 'circle', 'line', 'gradient'].includes(currentTool)) {
        drawShapePreview();
    }

    // Draw Pen Path Preview
    if (currentTool === 'pen' && penPath.length > 0) {
        mainCtx.save();
        mainCtx.lineWidth = 2 / zoomLevel;
        mainCtx.strokeStyle = '#0078d7';
        mainCtx.beginPath();
        for (let i = 0; i < penPath.length; i++) {
            const pt = penPath[i];
            if (pt.type === 'M') {
                mainCtx.moveTo(pt.x, pt.y);
            } else if (pt.type === 'L') {
                mainCtx.lineTo(pt.x, pt.y);
            } else if (pt.type === 'Q') {
                mainCtx.quadraticCurveTo(pt.cp1x, pt.cp1y, pt.x, pt.y);
            } else if (pt.type === 'C') {
                mainCtx.bezierCurveTo(pt.cp1x, pt.cp1y, pt.cp2x, pt.cp2y, pt.x, pt.y);
            }
        }

        // Line to current mouse or drag curve preview
        if (window.lastMouseX !== undefined) {
            if (isDraggingPen) {
                // We are dragging the current node's control point
                // Control point is reflected from the drag point
                const currentX = startX;
                const currentY = startY;
                const cpX = window.lastMouseX;
                const cpY = window.lastMouseY;

                // Draw line to current node
                mainCtx.lineTo(currentX, currentY);

                // Draw handle (from current to mouse)
                mainCtx.save();
                mainCtx.strokeStyle = '#aaa';
                mainCtx.lineWidth = 1 / zoomLevel;
                mainCtx.beginPath();
                mainCtx.moveTo(currentX, currentY);
                mainCtx.lineTo(cpX, cpY);
                // Draw reflected handle
                const rX = currentX - (cpX - currentX);
                const rY = currentY - (cpY - currentY);
                mainCtx.moveTo(currentX, currentY);
                mainCtx.lineTo(rX, rY);
                mainCtx.stroke();

                // Draw handle ends
                mainCtx.fillStyle = '#fff';
                mainCtx.fillRect(cpX-2, cpY-2, 4, 4);
                mainCtx.fillRect(rX-2, rY-2, 4, 4);
                mainCtx.restore();

            } else {
                 // Not dragging, just moving mouse to place next point
                 // Draw preview line to mouse
                 if (penPath.length > 0) {
                     const last = penPath[penPath.length - 1];
                     if (last.type === 'Q' || last.type === 'C' || last.cp2x) {
                          // Previous node had a handle. The control point for the incoming curve is the reflection of the outgoing handle
                          // Last point's OUTGOING handle was recorded as cp2x, cp2y. Wait, let's keep it simple.
                          // Real pen tool preview requires C. We will just draw a line for now to keep preview simple,
                          // or draw quadratic if we want to show curve preview.
                          // Actually, a simple line is fine for previewing next anchor location.
                          mainCtx.lineTo(window.lastMouseX, window.lastMouseY);
                     } else {
                          mainCtx.lineTo(window.lastMouseX, window.lastMouseY);
                     }
                 }
            }
        }
        mainCtx.stroke();

        // Draw path nodes
        mainCtx.fillStyle = '#fff';
        mainCtx.strokeStyle = '#000';
        mainCtx.lineWidth = 1 / zoomLevel;
        const ptSize = 6 / zoomLevel;
        penPath.forEach(pt => {
            mainCtx.fillRect(pt.x - ptSize/2, pt.y - ptSize/2, ptSize, ptSize);
            mainCtx.strokeRect(pt.x - ptSize/2, pt.y - ptSize/2, ptSize, ptSize);
        });
        mainCtx.restore();
    }

    // Draw Polygon Lasso Preview
    if (currentTool === 'poly-lasso' && polygonPoints.length > 0) {
        mainCtx.save();
        mainCtx.lineWidth = 1 / zoomLevel;
        mainCtx.strokeStyle = '#000';
        mainCtx.setLineDash([5 / zoomLevel, 5 / zoomLevel]);
        mainCtx.beginPath();
        mainCtx.moveTo(polygonPoints[0][0], polygonPoints[0][1]);
        for(let i=1; i<polygonPoints.length; i++) {
            mainCtx.lineTo(polygonPoints[i][0], polygonPoints[i][1]);
        }
        // Line to current mouse
        if (window.lastMouseX !== undefined) {
             // Need to transform window.lastMouseX (global canvas coords) to view
             // renderCanvas already has transforms applied!
             // So we draw using global coords directly.
             mainCtx.lineTo(window.lastMouseX, window.lastMouseY);
        }
        mainCtx.stroke();

        // Draw points
        mainCtx.fillStyle = '#fff';
        mainCtx.strokeStyle = '#000';
        mainCtx.setLineDash([]);
        const ptSize = 4 / zoomLevel;
        polygonPoints.forEach(p => {
            mainCtx.fillRect(p[0] - ptSize/2, p[1] - ptSize/2, ptSize, ptSize);
            mainCtx.strokeRect(p[0] - ptSize/2, p[1] - ptSize/2, ptSize, ptSize);
        });

        mainCtx.restore();
    }

    // Draw Clone Source preview
    if (currentTool === 'clone' && cloneSourceX !== null) {
        mainCtx.save();
        mainCtx.strokeStyle = '#000';
        mainCtx.lineWidth = 1 / zoomLevel;
        mainCtx.beginPath();
        // Just a crosshair at source
        // Since sourceX/Y are global, we transform them to view
        const screenX = (cloneSourceX * zoomLevel) + panX;
        const screenY = (cloneSourceY * zoomLevel) + panY;

        // Wait, renderCanvas applies transforms. We should draw at cloneSourceX directly.
        mainCtx.lineWidth = 2 / zoomLevel;
        mainCtx.strokeStyle = 'rgba(0,0,0,0.5)';
        const size = 10 / zoomLevel;
        mainCtx.moveTo(cloneSourceX - size, cloneSourceY);
        mainCtx.lineTo(cloneSourceX + size, cloneSourceY);
        mainCtx.moveTo(cloneSourceX, cloneSourceY - size);
        mainCtx.lineTo(cloneSourceX, cloneSourceY + size);
        mainCtx.stroke();
        mainCtx.restore();
    }

    mainCtx.restore(); // Restore context to default state (no transform)

    updateHistogram(); // Update histogram after rendering
}

function drawCheckerboard(ctx, w, h) {
    const size = 10;
    ctx.fillStyle = '#ccc';
    ctx.fillRect(0,0,w,h);
    ctx.fillStyle = '#fff';
    for(let y=0; y<h; y+=size) {
        for(let x=0; x<w; x+=size) {
            if((x/size + y/size) % 2 === 0) ctx.fillRect(x,y,size,size);
        }
    }
}

function applyLayerStyle(type) {
    const layer = layerManager.getActiveLayer();
    if (!layer) return;

    if (type === 'shadow') {
        const color = prompt("Enter Shadow Color (Hex or rgba):", layer.shadowColor || 'rgba(0,0,0,0.5)');
        if (!color) return;
        const blur = prompt("Enter Blur Radius:", layer.shadowBlur || 10);
        const offsetX = prompt("Enter Offset X:", layer.shadowOffsetX || 5);
        const offsetY = prompt("Enter Offset Y:", layer.shadowOffsetY || 5);

        layer.shadowColor = color;
        layer.shadowBlur = parseFloat(blur) || 0;
        layer.shadowOffsetX = parseFloat(offsetX) || 0;
        layer.shadowOffsetY = parseFloat(offsetY) || 0;

        historyManager.saveState();
        renderCanvas();
    }
}

function renderLayerList() {
    const list = document.getElementById('layer-list');
    list.innerHTML = '';

    // Render in reverse order (top layer at top of list)
    [...layerManager.layers].reverse().forEach(layer => {
        const item = document.createElement('div');
        item.className = `layer-item ${layer.id === layerManager.activeLayerId ? 'active' : ''}`;
        item.onclick = () => {
            layerManager.activeLayerId = layer.id;
            renderLayerList();
        };

        const eye = document.createElement('span');
        eye.className = 'layer-eye';
        eye.innerText = layer.visible ? 'üëÅÔ∏è' : '‚óã';
        eye.onclick = (e) => {
            e.stopPropagation();
            layerManager.toggleVisibility(layer.id);
        };

        const name = document.createElement('span');
        name.innerText = layer.name;

        item.appendChild(eye);
        item.appendChild(name);
        list.appendChild(item);
    });
}


// --- Event Listeners ---
mainCanvas.addEventListener('mousedown', startPosition);
// Prevent context menu on right click to allow drawing with secondary color
mainCanvas.addEventListener('contextmenu', e => e.preventDefault());
// Bind mouseup to window to ensure we catch it even if dragged outside canvas
window.addEventListener('mouseup', endPosition);
mainCanvas.addEventListener('mousemove', draw);
mainCanvas.addEventListener('mouseleave', endPosition); // Stop drawing if mouse leaves canvas bounds
mainCanvas.addEventListener('click', handleCanvasClick);
mainCanvas.addEventListener('wheel', handleWheel); // Zoom support
mainCanvas.addEventListener('dblclick', handleDoubleClick); // Crop confirmation

// Input Listeners
document.getElementById('brush-size').addEventListener('input', (e) => {
    brushSize = e.target.value;
    document.getElementById('brush-size-val').innerText = brushSize + 'px';
});
document.getElementById('brush-opacity').addEventListener('input', (e) => {
    brushOpacity = e.target.value / 100;
    document.getElementById('brush-opacity-val').innerText = e.target.value + '%';
});
document.getElementById('primary-color').addEventListener('input', (e) => {
    brushColor = e.target.value;
});
document.getElementById('primary-color').addEventListener('change', (e) => {
    // Add to history on commit (mouse up)
    addToColorHistory(e.target.value);
});
document.getElementById('secondary-color').addEventListener('input', (e) => {
    secondaryColor = e.target.value;
});

// New UI Listeners
let shapeSides = 5;
let shapeRadius = 10;
document.getElementById('shape-sides').addEventListener('input', (e) => { shapeSides = parseInt(e.target.value) || 5; });
document.getElementById('shape-radius').addEventListener('input', (e) => { shapeRadius = parseInt(e.target.value) || 10; });

document.getElementById('brush-hardness').addEventListener('input', (e) => {
    brushHardness = parseInt(e.target.value);
    document.getElementById('brush-hardness-val').innerText = brushHardness + '%';
});

document.getElementById('brush-smoothing').addEventListener('input', (e) => {
    brushSmoothing = parseInt(e.target.value);
    document.getElementById('brush-smoothing-val').innerText = brushSmoothing + '%';
});

document.getElementById('brush-type').addEventListener('change', (e) => {
    brushType = e.target.value;
});

document.getElementById('airbrush-toggle').addEventListener('change', (e) => {
    isAirbrush = e.target.checked;
});

document.getElementById('shape-fill').addEventListener('change', (e) => {
    shapeFill = e.target.checked;
});

document.getElementById('shape-stroke').addEventListener('change', (e) => {
    shapeStroke = e.target.checked;
});

document.getElementById('font-family').addEventListener('change', (e) => {
    fontFamily = e.target.value;
});
document.getElementById('font-bold').addEventListener('change', (e) => {
    fontBold = e.target.checked;
});
document.getElementById('font-italic').addEventListener('change', (e) => {
    fontItalic = e.target.checked;
});
document.getElementById('wand-tolerance').addEventListener('change', (e) => {
    wandTolerance = parseInt(e.target.value) || 30;
});

document.getElementById('spray-type').addEventListener('change', (e) => {
    sprayType = e.target.value;
});

// --- Coordinate Helper ---
function getCanvasCoordinates(e) {
    const rect = mainCanvas.getBoundingClientRect();
    const screenX = e.clientX - rect.left;
    const screenY = e.clientY - rect.top;

    // Inverse transform
    const canvasX = (screenX - panX) / zoomLevel;
    const canvasY = (screenY - panY) / zoomLevel;

    return { x: canvasX, y: canvasY, screenX, screenY };
}


// --- Drawing Engine ---
function startPosition(e) {
    // Handle Pan Tool (Spacebar held or middle click)
    if (isSpacePressed || e.button === 1) {
        isPanning = true;
        const coords = getCanvasCoordinates(e);
        lastPanX = coords.screenX;
        lastPanY = coords.screenY;
        mainCanvas.style.cursor = 'grabbing';
        return;
    }

    // Determine active drawing color (Left click = Primary, Right click = Secondary)
    activeColor = e.button === 2 ? secondaryColor : brushColor;

    const coords = getCanvasCoordinates(e);
    startX = coords.x;
    startY = coords.y;

    // Store globally for Airbrush
    window.lastMouseX = coords.x;
    window.lastMouseY = coords.y;

    if (currentTool === 'move') {
        const layer = layerManager.getActiveLayer();
        if (layer) {
            painting = true;
            lastMoveX = coords.x;
            lastMoveY = coords.y;
        }
        return;
    }

    // Clone Stamp Source Set (Alt + Click)
    if (currentTool === 'clone' && e.altKey) {
        cloneSourceX = startX;
        cloneSourceY = startY;
        console.log("Clone Source Set:", cloneSourceX, cloneSourceY);
        renderCanvas();
        return;
    }

    if (['fill', 'picker', 'text', 'wand', 'poly-lasso'].includes(currentTool)) return; // These are handled by click (poly-lasso needs special click handling)

    if (currentTool === 'pen') {
        isDraggingPen = true;
        // Pen tool drag means manipulating the handle for the point we just added in click
        // Or if we mouse down and drag, we are setting the handle for a new node.
        // Let's modify behavior: click places node, drag sets its handle.
        // We handle the actual node placement in mouseup to see if it was a drag or click.
        return;
    }

    // Refresh Clone Source Snapshot
    if (currentTool === 'clone' && !e.altKey) {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = layerManager.width;
        tempCanvas.height = layerManager.height;
        const tCtx = tempCanvas.getContext('2d');

        // Draw background checkerboard? No, just layers.
        // Actually, we usually clone what is visible.
        // Replicate render logic (without zoom/pan)
        layerManager.layers.forEach(layer => {
            if (!layer.visible) return;
            tCtx.save();
            tCtx.globalAlpha = layer.opacity;
            tCtx.globalCompositeOperation = layer.blendMode;

            const centerX = (layer.x || 0) + layer.canvas.width / 2;
            const centerY = (layer.y || 0) + layer.canvas.height / 2;

            tCtx.translate(centerX, centerY);
            tCtx.rotate(layer.rotation || 0);
            tCtx.scale(layer.scaleX || 1, layer.scaleY || 1);
            tCtx.translate(-centerX, -centerY);

            tCtx.drawImage(layer.canvas, layer.x || 0, layer.y || 0);
            tCtx.restore();
        });
        window.cloneSourceImage = tempCanvas;
    }

    painting = true;

    if (currentTool === 'marquee' || currentTool === 'lasso' || currentTool === 'crop') {
        selectionManager.startSelection(startX, startY);
        return;
    }

    if (selectionManager.hasSelection && (currentTool === 'brush' || currentTool === 'eraser' || currentTool === 'clone')) {
        const layer = layerManager.getActiveLayer();
        if(layer) {
            layer.ctx.save();
            layer.ctx.beginPath();
        }
    }

    // Reset last position for brush interpolation
    window.lastX = startX - (layerManager.getActiveLayer()?.x || 0);
    window.lastY = startY - (layerManager.getActiveLayer()?.y || 0);
    smoothedX = window.lastX;
    smoothedY = window.lastY;

    // Store globally for shape previews
    window.lastMouseX = startX;
    window.lastMouseY = startY;

    // Handle Polygon Lasso - Preview line
    if (currentTool === 'poly-lasso' && polygonPoints.length > 0) {
        // Just force render to show the preview line from last point to mouse
        renderCanvas();
    }

    const advancedBrushes = ['smudge', 'blur-brush', 'sharpen-brush', 'dodge', 'burn', 'spray', 'watercolor', 'marker', 'pencil'];
    if (currentTool === 'brush' || currentTool === 'eraser' || currentTool === 'clone' || advancedBrushes.includes(currentTool)) {
const isContinuous = (isAirbrush && currentTool === 'brush') || currentTool === 'spray';

        if (isContinuous) {
            clearInterval(airbrushInterval);
            airbrushInterval = setInterval(() => {
                if (painting) {
                    if (currentTool === 'spray') {
                        draw(null, true); // Mock continuous spray
                    } else {
                        drawAirbrush();
                    }
                }
            }, 50); // 20 times a second

            if (currentTool === 'spray') {
                draw(e);
            } else {
                drawAirbrush();
            }
        } else {
            draw(e);
        }
    }
}

function endPosition(e) {
    clearInterval(airbrushInterval);
    if (isPanning) {
        isPanning = false;
        mainCanvas.style.cursor = isSpacePressed ? 'grab' : getCursorForTool(currentTool);
        return;
    }

    if (painting) {
        const coords = getCanvasCoordinates(e);
        const endX = coords.x;
        const endY = coords.y;

        painting = false;

        if (currentTool === 'move') {
            historyManager.saveState();
            return;
        }

        if (currentTool === 'pen') {
            isDraggingPen = false;

            // Calculate if it was a click or a drag
            const dist = Math.hypot(endX - startX, endY - startY);

            if (penPath.length === 0) {
                 if (dist < 2) {
                     penPath.push({x: startX, y: startY, type: 'M'});
                 } else {
                     // Drag on first point sets initial control handle (which affects the NEXT segment's starting angle, but for M it's often ignored or used for C)
                     // For simplicity, we just store it as M with an outgoing handle
                     penPath.push({x: startX, y: startY, type: 'M', outX: startX - (endX - startX), outY: startY - (endY - startY)});
                 }
            } else {
                 // Check if clicking near start to close
                 const startPt = penPath[0];
                 const closeDist = Math.hypot(startX - startPt.x, startY - startPt.y);
                 if (closeDist < 10 / zoomLevel) {
                     // Close path and rasterize
                     if (dist > 2) {
                         // Curving into the close
                         const prev = penPath[penPath.length-1];
                         const cp1x = prev.outX !== undefined ? prev.outX : prev.x;
                         const cp1y = prev.outY !== undefined ? prev.outY : prev.y;
                         const cp2x = endX; // The handle pulled out from the start point
                         const cp2y = endY;
                         penPath.push({x: startPt.x, y: startPt.y, type: 'C', cp1x, cp1y, cp2x, cp2y});
                     } else {
                         penPath.push({x: startPt.x, y: startPt.y, type: 'L'});
                     }
                     commitPenPath();
                     penPath = [];
                     renderCanvas();
                     return;
                 }

                 // Add new point
                 const prev = penPath[penPath.length-1];
                 const cp1x = prev.outX !== undefined ? prev.outX : prev.x;
                 const cp1y = prev.outY !== undefined ? prev.outY : prev.y;

                 if (dist < 2) {
                     // Straight line or curve to sharp point
                     if (prev.outX !== undefined) {
                          penPath.push({x: startX, y: startY, type: 'Q', cp1x: cp1x, cp1y: cp1y});
                     } else {
                          penPath.push({x: startX, y: startY, type: 'L'});
                     }
                 } else {
                     // Dragged, creates a smooth curve node.
                     // The mouse (endX, endY) defines the INCOMING handle (cp2).
                     // The OUTGOING handle is the reflection.
                     const cp2x = endX;
                     const cp2y = endY;
                     const outX = startX - (endX - startX);
                     const outY = startY - (endY - startY);

                     penPath.push({x: startX, y: startY, type: 'C', cp1x, cp1y, cp2x, cp2y, outX, outY});
                 }
            }
            renderCanvas();
            return;
        }

        if (currentTool === 'marquee' || currentTool === 'lasso' || currentTool === 'crop') {
            selectionManager.endSelection(endX, endY);
            if (currentTool === 'crop') {
                 // Don't crop immediately, wait for double click or enter?
                 // For now, let user see the selection.
                 // We will add a hint "Double click to Crop"
            }
            return;
        }

        const layer = layerManager.getActiveLayer();
        if(layer) {
            if (selectionManager.hasSelection) {
                 // Selection handling placeholder
            }

             // Commit shapes
            if (['rect', 'circle', 'line', 'rounded-rect', 'polygon', 'star'].includes(currentTool)) {
                layer.ctx.beginPath();
                layer.ctx.fillStyle = activeColor;
                layer.ctx.strokeStyle = activeColor;
                layer.ctx.lineWidth = brushSize;
                layer.ctx.lineJoin = 'round';

                if (currentTool === 'rect') {
                    layer.ctx.rect(startX, startY, endX - startX, endY - startY);
                } else if (currentTool === 'circle') {
                    const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                    layer.ctx.arc(startX, startY, radius, 0, Math.PI * 2);
                } else if (currentTool === 'line') {
                    layer.ctx.moveTo(startX, startY);
                    layer.ctx.lineTo(endX, endY);
                } else if (currentTool === 'rounded-rect') {
                    const w = endX - startX;
                    const h = endY - startY;
                    const r = Math.min(shapeRadius, Math.abs(w)/2, Math.abs(h)/2);
                    const x = startX;
                    const y = startY;
                    layer.ctx.moveTo(x + r, y);
                    layer.ctx.lineTo(x + w - r, y);
                    layer.ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                    layer.ctx.lineTo(x + w, y + h - r);
                    layer.ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                    layer.ctx.lineTo(x + r, y + h);
                    layer.ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                    layer.ctx.lineTo(x, y + r);
                    layer.ctx.quadraticCurveTo(x, y, x + r, y);
                } else if (currentTool === 'polygon' || currentTool === 'star') {
                    const cx = startX;
                    const cy = startY;
                    const outerRadius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                    const angleStep = Math.PI / shapeSides;
                    let angle = -Math.PI / 2;

                    if (currentTool === 'star') {
                        const innerRadius = outerRadius * 0.5;
                        layer.ctx.moveTo(cx + Math.cos(angle) * outerRadius, cy + Math.sin(angle) * outerRadius);
                        for (let i = 0; i < shapeSides; i++) {
                            angle += angleStep;
                            layer.ctx.lineTo(cx + Math.cos(angle) * innerRadius, cy + Math.sin(angle) * innerRadius);
                            angle += angleStep;
                            layer.ctx.lineTo(cx + Math.cos(angle) * outerRadius, cy + Math.sin(angle) * outerRadius);
                        }
                    } else { // polygon
                        layer.ctx.moveTo(cx + Math.cos(angle) * outerRadius, cy + Math.sin(angle) * outerRadius);
                        for (let i = 0; i < shapeSides; i++) {
                            angle += angleStep * 2;
                            layer.ctx.lineTo(cx + Math.cos(angle) * outerRadius, cy + Math.sin(angle) * outerRadius);
                        }
                    }
                    layer.ctx.closePath();
                }

                if (currentTool === 'line') {
                    layer.ctx.stroke();
                } else {
                    if (shapeFill) layer.ctx.fill();
                    if (shapeStroke) layer.ctx.stroke();
                }
            } else if (currentTool === 'gradient') {
                // Apply Gradient
                const grad = layer.ctx.createLinearGradient(startX, startY, endX, endY);
                // If using secondary color, swap gradient direction
                if (activeColor === secondaryColor) {
                    grad.addColorStop(0, secondaryColor);
                    grad.addColorStop(1, brushColor);
                } else {
                    grad.addColorStop(0, brushColor);
                    grad.addColorStop(1, secondaryColor);
                }

                layer.ctx.fillStyle = grad;

                // If selection exists, clip to it
                if (selectionManager.hasSelection) {
                    layer.ctx.save();
                    // How to clip with the global selection mask?
                    // We need to draw the mask to context with 'destination-in' logic
                    // But we want to fill the area.
                    // Correct approach:
                    // 1. Fill a temp canvas/rect with gradient.
                    // 2. Composite that onto layer using selection mask.
                    // Or simpler: set clip if we had a path.
                    // With raster mask:
                    // Draw selection mask to layer with 'destination-in' to isolate gradient?
                    // No, that erases existing content.

                    // We need: (Layer Content) + (Gradient masked by Selection)
                    // So:
                    // 1. Draw gradient to layer (fills everything)
                    // 2. Wait, that overwrites.

                    // Correct:
                    // 1. Draw gradient on temp canvas.
                    // 2. Apply selection mask to temp canvas (make outside transparent).
                    // 3. Draw temp canvas to layer.

                    const temp = document.createElement('canvas');
                    temp.width = layer.canvas.width;
                    temp.height = layer.canvas.height;
                    const tCtx = temp.getContext('2d');

                    tCtx.fillStyle = grad;
                    tCtx.fillRect(0,0, temp.width, temp.height);

                    tCtx.globalCompositeOperation = 'destination-in';
                    tCtx.drawImage(selectionManager.maskCanvas, -layer.x, -layer.y); // Transform mask to local space

                    layer.ctx.drawImage(temp, 0, 0);
                    layer.ctx.restore();
                } else {
                    layer.ctx.fillRect(0, 0, layer.canvas.width, layer.canvas.height);
                }
            }

            layer.ctx.beginPath();
        }

        historyManager.saveState();
        renderCanvas();
    }
}

function drawAirbrush() {
    if (!painting) return;
    const layer = layerManager.getActiveLayer();
    if (!layer || !layer.visible) return;

    // Use last known coordinates (window.lastMouseX/Y are global canvas coords, need local)
    // Actually getCanvasCoordinates converts screen to global canvas space.
    // We need to store global canvas space for airbrush to persist at spot.

    // We can rely on window.lastMouseX/Y from draw() updates, but if mouse isn't moving, draw() isn't called.
    // So we need `draw(e)` to update position even if airbrush.

    const x = window.lastMouseX;
    const y = window.lastMouseY;

    if (x === undefined || y === undefined) return;

    const ctx = layer.ctx;
    ctx.save();

    const localX = (x - layer.x);
    const localY = (y - layer.y);

    // Airbrush Effect: Random spray or soft accumulation?
    // Usually soft accumulation for "Airbrush" in Photoshop (Flow).
    // Or spray for Paint. Let's do Soft Accumulation (Flow).

    const colorRgb = hexToRgb(activeColor);
    const rad = brushSize / 2;

    // Low opacity accumulation
    // We use a radial gradient to stamp
    const flow = 0.1; // 10% per tick

    const grad = ctx.createRadialGradient(localX, localY, 0, localX, localY, rad);
    grad.addColorStop(0, `rgba(${colorRgb}, ${flow * brushOpacity})`);
    grad.addColorStop(1, `rgba(${colorRgb}, 0)`);

    ctx.fillStyle = grad;
    ctx.globalCompositeOperation = 'source-over'; // Accumulate
    ctx.beginPath();
    ctx.arc(localX, localY, rad, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
    renderCanvas();
}

function draw(e, isContinuousMock = false) {
    let x, y;
    if (isContinuousMock) {
        x = window.lastMouseX;
        y = window.lastMouseY;
        if (x === undefined || y === undefined) return;
    } else {
        const coords = getCanvasCoordinates(e);
        x = coords.x;
        y = coords.y;

        // Handle Panning
        if (isPanning) {
            const dx = coords.screenX - lastPanX;
            const dy = coords.screenY - lastPanY;
            panX += dx;
            panY += dy;
            lastPanX = coords.screenX;
            lastPanY = coords.screenY;
            renderCanvas();
            return;
        }

        // Update coordinates for preview
        window.lastMouseX = x;
        window.lastMouseY = y;
    }

    if (currentTool === 'pen' && isDraggingPen) {
        renderCanvas();
        return;
    }

    if (!painting) return;

    const layer = layerManager.getActiveLayer();
    if (!layer || !layer.visible) return;

    if (currentTool === 'move') {
        const dx = x - lastMoveX;
        const dy = y - lastMoveY;
        layer.x += dx;
        layer.y += dy;
        lastMoveX = x;
        lastMoveY = y;
        renderCanvas();
        return;
    }

    // Handle Selection Tools
    if (currentTool === 'marquee' || currentTool === 'lasso' || currentTool === 'crop') {
        selectionManager.updateSelection(x, y);
        return;
    }

    // Handle Brush/Eraser/Clone/Advanced Brushes (Real-time)
    const advancedBrushes = ['smudge', 'blur-brush', 'sharpen-brush', 'dodge', 'burn', 'spray', 'watercolor', 'marker', 'pencil'];
    if (currentTool === 'brush' || currentTool === 'eraser' || currentTool === 'clone' || advancedBrushes.includes(currentTool)) {
        const layer = layerManager.getActiveLayer();
        if(layer && selectionManager.hasSelection) {
            if (!window.selectionSnapshotCanvas) {
                window.selectionSnapshotCanvas = document.createElement('canvas');
            }
            window.selectionSnapshotCanvas.width = layer.canvas.width;
            window.selectionSnapshotCanvas.height = layer.canvas.height;
            window.selectionSnapshotCanvas.getContext('2d').clearRect(0, 0, layer.canvas.width, layer.canvas.height);
            window.selectionSnapshotCanvas.getContext('2d').drawImage(layer.canvas, 0, 0);
        }

        // If Airbrush is on, we just update coordinates for the interval loop and return
        if (isAirbrush && currentTool === 'brush') {
             // Update global tracking vars for the interval loop
             window.lastMouseX = x;
             window.lastMouseY = y;
             return;
        }

        const rawLocalX = (x - layer.x);
        const rawLocalY = (y - layer.y);

        // Calculate Smoothing Factor (0 to 1)
        // 0% -> instant follow (factor 1)
        // 100% -> very slow follow (factor ~0.05)
        const sFactor = 1 - (brushSmoothing / 100) * 0.95;

        // Apply LERP (Linear Interpolation)
        smoothedX = smoothedX + (rawLocalX - smoothedX) * sFactor;
        smoothedY = smoothedY + (rawLocalY - smoothedY) * sFactor;

        const localX = smoothedX;
        const localY = smoothedY;

        const ctx = layer.ctx;
        ctx.save();

        if (currentTool === 'clone') {
            if (cloneSourceX === null) return; // No source

            ctx.save();
            ctx.beginPath();
            ctx.arc(localX, localY, brushSize/2, 0, Math.PI*2);
            ctx.clip();
            ctx.translate(startX - cloneSourceX - layer.x, startY - cloneSourceY - layer.y);
            ctx.drawImage(window.cloneSourceImage, 0, 0);

            ctx.restore();
            // No stroke, we manually painted.

        } else if (advancedBrushes.includes(currentTool)) {
            // Advanced Brushes (Smudge, Blur, Sharpen, Dodge, Burn)
            const r = Math.ceil(brushSize / 2);

            let sampleMinX = Math.floor(localX - r);
            let sampleMinY = Math.floor(localY - r);
            let sampleMaxX = Math.ceil(localX + r);
            let sampleMaxY = Math.ceil(localY + r);

            if (currentTool === 'smudge' && window.lastX !== undefined) {
                 sampleMinX = Math.floor(Math.min(localX - r, window.lastX - r));
                 sampleMinY = Math.floor(Math.min(localY - r, window.lastY - r));
                 sampleMaxX = Math.ceil(Math.max(localX + r, window.lastX + r));
                 sampleMaxY = Math.ceil(Math.max(localY + r, window.lastY + r));
            }

            // Limit bounds to canvas size
            const minX = Math.max(0, sampleMinX);
            const minY = Math.max(0, sampleMinY);
            const maxX = Math.min(layer.canvas.width, sampleMaxX);
            const maxY = Math.min(layer.canvas.height, sampleMaxY);

            const bw = maxX - minX;
            const bh = maxY - minY;

            if (bw > 0 && bh > 0) {
                const imgData = ctx.getImageData(minX, minY, bw, bh);
                const data = imgData.data;
                const newImgData = ctx.createImageData(bw, bh);
                const newData = newImgData.data;
                newData.set(data); // Copy original as base

                // Use an appropriately scaled strength (brushOpacity is 0-1)
                // Note: The input listener sets brushOpacity = e.target.value / 100, so it is already 0-1.
                // However, for Dodge/Burn, 0-1 as a direct multiplier per frame is still too strong.
                // We need to scale the effect per tick.
                const strength = brushOpacity;

                if (currentTool === 'smudge') {
                    // Pull pixels from previous mouse position
                    if (window.lastX !== undefined && window.lastY !== undefined) {
                        const dx = localX - window.lastX;
                        const dy = localY - window.lastY;

                        // Steps for interpolation if mouse moved fast
                        const dist = Math.hypot(dx, dy);
                        const steps = Math.max(1, Math.ceil(dist / (r * 0.5))); // Interpolate heavily

                        for (let s = 1; s <= steps; s++) {
                             const t = s / steps;
                             const curX = window.lastX + dx * t;
                             const curY = window.lastY + dy * t;

                             // Small offset vector for source pixel
                             const sdx = dx / steps;
                             const sdy = dy / steps;

                             for (let py = 0; py < bh; py++) {
                                for (let px = 0; px < bw; px++) {
                                    const realX = px + minX;
                                    const realY = py + minY;

                                    const dCenter = Math.hypot(realX - curX, realY - curY);
                                    if (dCenter <= r) {
                                        // Soft edge falloff
                                        const falloff = 1 - (dCenter / r);
                                        const effect = falloff * strength * 0.5; // Scale down for multi-step

                                        // Source pixel coords (behind current step)
                                        let sx = Math.round(px - sdx);
                                        let sy = Math.round(py - sdy);

                                        // Only sample if source is within the fetched box
                                        if (sx >= 0 && sx < bw && sy >= 0 && sy < bh) {
                                            const sIdx = (sy * bw + sx) * 4;
                                            const dIdx = (py * bw + px) * 4;

                                            // Blend (reading from newData so intermediate steps affect each other, or data for independent? newData better for smudge)
                                            newData[dIdx] = newData[dIdx] * (1 - effect) + newData[sIdx] * effect;
                                            newData[dIdx+1] = newData[dIdx+1] * (1 - effect) + newData[sIdx+1] * effect;
                                            newData[dIdx+2] = newData[dIdx+2] * (1 - effect) + newData[sIdx+2] * effect;
                                            newData[dIdx+3] = newData[dIdx+3] * (1 - effect) + newData[sIdx+3] * effect;
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else if (currentTool === 'dodge' || currentTool === 'burn') {
                    // Scale strength to be mild per-tick (max 5% change per tick at 100% opacity)
                    const effectStrength = strength * 0.05;
                    const factor = currentTool === 'dodge' ? (1 + effectStrength) : (1 - effectStrength);

                    for (let py = 0; py < bh; py++) {
                        for (let px = 0; px < bw; px++) {
                            const realX = px + minX;
                            const realY = py + minY;
                            const dCenter = Math.hypot(realX - localX, realY - localY);

                            if (dCenter <= r) {
                                const falloff = 1 - (dCenter / r);
                                const currentFactor = 1 + (factor - 1) * falloff;
                                const idx = (py * bw + px) * 4;

                                if (newData[idx+3] > 0) { // Only affect non-transparent
                                    newData[idx] = Math.min(255, Math.max(0, newData[idx] * currentFactor));
                                    newData[idx+1] = Math.min(255, Math.max(0, newData[idx+1] * currentFactor));
                                    newData[idx+2] = Math.min(255, Math.max(0, newData[idx+2] * currentFactor));
                                }
                            }
                        }
                    }
                } else if (currentTool === 'blur-brush' || currentTool === 'sharpen-brush') {
                    // Mini convolution kernel for brush area
                    let kernel;
                    if (currentTool === 'blur-brush') {
                        kernel = [1/9, 1/9, 1/9, 1/9, 1/9, 1/9, 1/9, 1/9, 1/9];
                    } else {
                        // Mild sharpen to prevent artifacts
                        kernel = [0, -0.5, 0, -0.5, 3, -0.5, 0, -0.5, 0];
                    }

                    const kSide = 3;
                    const halfK = 1;

                    for (let py = 0; py < bh; py++) {
                        for (let px = 0; px < bw; px++) {
                            const realX = px + minX;
                            const realY = py + minY;
                            const dCenter = Math.hypot(realX - localX, realY - localY);

                            if (dCenter <= r) {
                                const falloff = 1 - (dCenter / r);
                                // Limit blur/sharpen effect per tick
                                const effect = falloff * strength * 0.3;
                                const idx = (py * bw + px) * 4;

                                if (newData[idx+3] > 0) {
                                    let r_val = 0, g = 0, b = 0;
                                    let wSum = 0;
                                    for (let ky = 0; ky < kSide; ky++) {
                                        for (let kx = 0; kx < kSide; kx++) {
                                            const scy = py + ky - halfK;
                                            const scx = px + kx - halfK;
                                            if (scy >= 0 && scy < bh && scx >= 0 && scx < bw) {
                                                const sIdx = (scy * bw + scx) * 4;
                                                const wt = kernel[ky * kSide + kx];
                                                r_val += data[sIdx] * wt;
                                                g += data[sIdx+1] * wt;
                                                b += data[sIdx+2] * wt;
                                                wSum += wt;
                                            }
                                        }
                                    }
                                    if (wSum > 0) { r_val/=wSum; g/=wSum; b/=wSum; }

                                    // Use newData for current state so effect doesn't just read from original unmodified frame state inside the loop
                                    newData[idx] = newData[idx] * (1-effect) + r_val * effect;
                                    newData[idx+1] = newData[idx+1] * (1-effect) + g * effect;
                                    newData[idx+2] = newData[idx+2] * (1-effect) + b * effect;
                                }
                            }
                        }
                    }
                }

                ctx.putImageData(newImgData, minX, minY);
            }


        } else if (currentTool === 'spray') {
            const colorRgb = hexToRgb(activeColor);

            let radius = brushSize / 2;
            let density = brushSize; // amount of dots per tick

            if (sprayType === 'wide') {
                radius = brushSize;
                density = brushSize * 2;
            } else if (sprayType === 'thin') {
                radius = brushSize / 4;
                density = brushSize / 2;
            }

            if (sprayType === 'soft') {
                 // Soft radial burst instead of dots
                 const grad = ctx.createRadialGradient(localX, localY, 0, localX, localY, radius);
                 grad.addColorStop(0, `rgba(${colorRgb}, ${brushOpacity * 0.1})`);
                 grad.addColorStop(1, `rgba(${colorRgb}, 0)`);
                 ctx.fillStyle = grad;
                 ctx.beginPath();
                 ctx.arc(localX, localY, radius, 0, Math.PI * 2);
                 ctx.fill();
            } else {
                 // Scattered dots
                 ctx.fillStyle = `rgba(${colorRgb}, ${brushOpacity})`;
                 for (let i = 0; i < density; i++) {
                     const r = radius * Math.sqrt(Math.random());
                     const theta = Math.random() * 2 * Math.PI;
                     const dotX = localX + r * Math.cos(theta);
                     const dotY = localY + r * Math.sin(theta);
                     ctx.fillRect(dotX, dotY, 1, 1);
                 }
            }

        } else if (currentTool === 'watercolor') {
            const colorRgb = hexToRgb(activeColor);

            // Watercolor effect: overlapping semi-transparent circles with slight jitter
            const dist = Math.hypot(localX - (window.lastX || localX), localY - (window.lastY || localY));
            const steps = Math.ceil(dist / (brushSize * 0.25)); // High overlap

            ctx.globalCompositeOperation = 'multiply';

            for (let i = 0; i <= steps; i++) {
                const t = steps === 0 ? 1 : i / steps;
                let cx = (window.lastX || localX) + (localX - (window.lastX || localX)) * t;
                let cy = (window.lastY || localY) + (localY - (window.lastY || localY)) * t;

                // Add slight jitter for natural edge
                cx += (Math.random() - 0.5) * brushSize * 0.1;
                cy += (Math.random() - 0.5) * brushSize * 0.1;

                const grad = ctx.createRadialGradient(cx, cy, brushSize/4, cx, cy, brushSize/2);
                grad.addColorStop(0, `rgba(${colorRgb}, ${brushOpacity * 0.2})`); // Core is denser
                grad.addColorStop(1, `rgba(${colorRgb}, 0)`); // Edge fades out softly

                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(cx, cy, brushSize/2, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalCompositeOperation = 'source-over';

        } else if (currentTool === 'marker') {
            const colorRgb = hexToRgb(activeColor);

            // Marker effect: flat semi-transparent hard edge, overlapping darkens
            const dist = Math.hypot(localX - (window.lastX || localX), localY - (window.lastY || localY));
            const steps = Math.ceil(dist);

            // We use 'multiply' to simulate marker ink overlapping
            ctx.globalCompositeOperation = 'multiply';
            ctx.fillStyle = `rgba(${colorRgb}, ${brushOpacity * 0.5})`; // Always partly transparent

            for (let i = 0; i <= steps; i++) {
                const t = steps === 0 ? 1 : i / steps;
                const cx = (window.lastX || localX) + (localX - (window.lastX || localX)) * t;
                const cy = (window.lastY || localY) + (localY - (window.lastY || localY)) * t;

                ctx.beginPath();
                ctx.arc(cx, cy, brushSize/2, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalCompositeOperation = 'source-over';

        } else if (currentTool === 'pencil') {
            const colorRgb = hexToRgb(activeColor);

            // Pencil effect: thin, hard edge with low opacity and jitter
            const dist = Math.hypot(localX - (window.lastX || localX), localY - (window.lastY || localY));
            const steps = Math.ceil(dist);

            ctx.fillStyle = `rgba(${colorRgb}, ${brushOpacity * 0.7})`;

            for (let i = 0; i <= steps; i++) {
                const t = steps === 0 ? 1 : i / steps;
                let cx = (window.lastX || localX) + (localX - (window.lastX || localX)) * t;
                let cy = (window.lastY || localY) + (localY - (window.lastY || localY)) * t;

                // Jitter to simulate paper texture
                cx += (Math.random() - 0.5) * 1;
                cy += (Math.random() - 0.5) * 1;

                // Draw small 1x1 or 2x2 blocks depending on brush size, but cap the actual drawn size
                const pencilSize = Math.max(1, Math.min(brushSize, 3));

                ctx.fillRect(cx - pencilSize/2, cy - pencilSize/2, pencilSize, pencilSize);
            }

        } else if (currentTool === 'eraser') {
            ctx.lineWidth = brushSize;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalCompositeOperation = 'destination-out';
            ctx.strokeStyle = `rgba(0,0,0,1)`;

            ctx.lineTo(localX, localY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(localX, localY);
            ctx.globalCompositeOperation = 'source-over';
        } else {
            // Normal Brush Logic
            const colorRgb = hexToRgb(activeColor);

            if (brushType === 'square') {
                // Square Brush (Axis Aligned)
                ctx.fillStyle = `rgba(${colorRgb}, ${brushOpacity})`;

                // Interpolation loop
                const dist = Math.hypot(localX - (window.lastX || localX), localY - (window.lastY || localY));
                const steps = Math.ceil(dist); // 1 pixel step

                for (let i = 0; i <= steps; i++) {
                    const t = steps === 0 ? 0 : i / steps;
                    const cx = (window.lastX || localX) + (localX - (window.lastX || localX)) * t;
                    const cy = (window.lastY || localY) + (localY - (window.lastY || localY)) * t;

                    // Draw centered square
                    ctx.fillRect(cx - brushSize/2, cy - brushSize/2, brushSize, brushSize);
                }

            } else if (brushType === 'calligraphy') {
                // Calligraphy Brush (Oval)
                // Fixed angle oval.
                // We must draw multiple ovals along the path.
                const dist = Math.hypot(localX - (window.lastX || localX), localY - (window.lastY || localY));
                const angle = Math.atan2(localY - (window.lastY || localY), localX - (window.lastX || localX));

                const steps = Math.ceil(dist); // 1 step per pixel

                ctx.fillStyle = `rgba(${colorRgb}, ${brushOpacity})`;

                for (let i = 0; i < steps; i++) {
                    const t = i / steps;
                    const cx = (window.lastX || localX) + (localX - (window.lastX || localX)) * t;
                    const cy = (window.lastY || localY) + (localY - (window.lastY || localY)) * t;

                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.rotate(-45 * Math.PI / 180); // Fixed 45 degree angle
                    ctx.scale(1, 0.2); // Flatten to create calligraphy effect
                    ctx.beginPath();
                    ctx.arc(0, 0, brushSize / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

            } else {
                // Round Brush with Hardness
                // If hardness is 100, use standard stroke.
                // If hardness < 100, we need soft edges. Canvas API stroke doesn't support radial gradient brushes easily.
                // We must use 'shadowBlur' or draw circles with gradients.

                if (brushHardness >= 95) {
                    ctx.lineWidth = brushSize;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.strokeStyle = `rgba(${colorRgb}, ${brushOpacity})`;
                    ctx.lineTo(localX, localY);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(localX, localY);
                } else {
                    // Soft Brush (drawing repeated circles with gradient)
                    const dist = Math.hypot(localX - (window.lastX || localX), localY - (window.lastY || localY));
                    const steps = Math.ceil(dist / (brushSize * 0.1)); // Optimization: step size based on brush size

                    for (let i = 0; i <= steps; i++) {
                        const t = i / Math.max(steps, 1);
                        const cx = (window.lastX || localX) + (localX - (window.lastX || localX)) * t;
                        const cy = (window.lastY || localY) + (localY - (window.lastY || localY)) * t;

                        const rad = brushSize / 2;
                        const grad = ctx.createRadialGradient(cx, cy, rad * (brushHardness/100), cx, cy, rad);
                        grad.addColorStop(0, `rgba(${colorRgb}, ${brushOpacity})`);
                        grad.addColorStop(1, `rgba(${colorRgb}, 0)`);

                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.arc(cx, cy, rad, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        if (selectionManager.hasSelection && window.selectionSnapshotCanvas) {
            // Restore unselected pixels from snapshot
            // We only need to process the bounding box of the stroke segment to be fast
            const r = Math.ceil(brushSize / 2);

            // localX/Y are the CURRENT point. window.lastX/Y are the PREVIOUS point.
            const lx = window.lastX !== undefined ? window.lastX : localX;
            const ly = window.lastY !== undefined ? window.lastY : localY;

            const minX = Math.max(0, Math.floor(Math.min(localX - r, lx - r)));
            const minY = Math.max(0, Math.floor(Math.min(localY - r, ly - r)));
            const maxX = Math.min(layer.canvas.width, Math.ceil(Math.max(localX + r, lx + r)));
            const maxY = Math.min(layer.canvas.height, Math.ceil(Math.max(localY + r, ly + r)));
            const bw = maxX - minX;
            const bh = maxY - minY;

            if (bw > 0 && bh > 0) {
                const layerData = ctx.getImageData(minX, minY, bw, bh);
                const snapData = window.selectionSnapshotCanvas.getContext('2d').getImageData(minX, minY, bw, bh);

                // Get mask data for the bounding box.
                // Mask coordinates are global, so add layer.x/layer.y.
                // layer.x/layer.y might be undefined or 0.
                const gx = minX + (layer.x || 0);
                const gy = minY + (layer.y || 0);

                let m = null;
                // If the bounding box is entirely within the main canvas:
                if (gx >= 0 && gy >= 0 && gx + bw <= selectionManager.width && gy + bh <= selectionManager.height) {
                    m = selectionManager.ctx.getImageData(gx, gy, bw, bh).data;
                } else {
                    // It goes out of bounds. The canvas API handles out of bounds by filling with 0 alpha transparent black.
                    m = selectionManager.ctx.getImageData(gx, gy, bw, bh).data;
                }

                const d = layerData.data;
                const s = snapData.data;

                for (let i = 0; i < d.length; i += 4) {
                    // selectionManager draws solid black for SELECTED pixels.
                    // So m[i+3] === 0 means UNSELECTED.
                    if (m[i+3] === 0) {
                        d[i] = s[i];
                        d[i+1] = s[i+1];
                        d[i+2] = s[i+2];
                        d[i+3] = s[i+3];
                    }
                }
                ctx.putImageData(layerData, minX, minY);
            }
        }

        window.lastX = localX;
        window.lastY = localY;

        ctx.restore();
        renderCanvas();
    } else {
        // For shapes, we just re-render to show the preview
        renderCanvas();
    }
}

function drawShapePreview() {
    const ctx = mainCtx;
    const x = window.lastMouseX;
    const y = window.lastMouseY;

    ctx.save();
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1 / zoomLevel;
    ctx.setLineDash([5 / zoomLevel, 5 / zoomLevel]);

    if (['rect', 'circle', 'line', 'rounded-rect', 'polygon', 'star'].includes(currentTool)) {
        ctx.beginPath();
        if (currentTool === 'rect') {
            ctx.rect(startX, startY, x - startX, y - startY);
        } else if (currentTool === 'circle') {
            const radius = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
            ctx.arc(startX, startY, radius, 0, Math.PI * 2);
        } else if (currentTool === 'line') {
            ctx.moveTo(startX, startY);
            ctx.lineTo(x, y);
        } else if (currentTool === 'rounded-rect') {
            const w = x - startX;
            const h = y - startY;
            const r = Math.min(shapeRadius, Math.abs(w)/2, Math.abs(h)/2);
            ctx.moveTo(startX + r, startY);
            ctx.lineTo(startX + w - r, startY);
            ctx.quadraticCurveTo(startX + w, startY, startX + w, startY + r);
            ctx.lineTo(startX + w, startY + h - r);
            ctx.quadraticCurveTo(startX + w, startY + h, startX + w - r, startY + h);
            ctx.lineTo(startX + r, startY + h);
            ctx.quadraticCurveTo(startX, startY + h, startX, startY + h - r);
            ctx.lineTo(startX, startY + r);
            ctx.quadraticCurveTo(startX, startY, startX + r, startY);
        } else if (currentTool === 'polygon' || currentTool === 'star') {
            const cx = startX;
            const cy = startY;
            const outerRadius = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
            const angleStep = Math.PI / shapeSides;
            let angle = -Math.PI / 2;

            if (currentTool === 'star') {
                const innerRadius = outerRadius * 0.5;
                ctx.moveTo(cx + Math.cos(angle) * outerRadius, cy + Math.sin(angle) * outerRadius);
                for (let i = 0; i < shapeSides; i++) {
                    angle += angleStep;
                    ctx.lineTo(cx + Math.cos(angle) * innerRadius, cy + Math.sin(angle) * innerRadius);
                    angle += angleStep;
                    ctx.lineTo(cx + Math.cos(angle) * outerRadius, cy + Math.sin(angle) * outerRadius);
                }
            } else {
                ctx.moveTo(cx + Math.cos(angle) * outerRadius, cy + Math.sin(angle) * outerRadius);
                for (let i = 0; i < shapeSides; i++) {
                    angle += angleStep * 2;
                    ctx.lineTo(cx + Math.cos(angle) * outerRadius, cy + Math.sin(angle) * outerRadius);
                }
            }
            ctx.closePath();
        }
        ctx.stroke();
    } else if (currentTool === 'gradient') {
        // Draw gradient vector line
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(x, y);
        ctx.setLineDash([]);
        ctx.stroke();

        // Draw arrow head?
        ctx.beginPath();
        ctx.arc(startX, startY, 3, 0, Math.PI*2);
        ctx.fill();
    }

    ctx.restore();
}

function handleCanvasClick(e) {
    if (isPanning) return;

    const coords = getCanvasCoordinates(e);
    const x = coords.x;
    const y = coords.y;

    const layer = layerManager.getActiveLayer();
    if (!layer || !layer.visible) return;

    // Transform to local
    const localX = x - layer.x;
    const localY = y - layer.y;

    // Determine active drawing color
    activeColor = e.button === 2 ? secondaryColor : brushColor;

    if (currentTool === 'fill') {
        if (selectionManager.hasSelection) {
            // Selection mask is global, so we use global x,y for mask check
            const maskPixel = selectionManager.ctx.getImageData(x, y, 1, 1).data;
            if (maskPixel[3] === 0) return;
        }

        floodFill(layer, Math.floor(localX), Math.floor(localY), hexToRgba(activeColor));
        historyManager.saveState();
        renderCanvas();
    } else if (currentTool === 'wand') {
        // Magic Wand Logic
        magicWandSelection(layer, Math.floor(localX), Math.floor(localY), wandTolerance);
    } else if (currentTool === 'picker') {
        const pixel = layer.ctx.getImageData(localX, localY, 1, 1).data;
        const hex = rgbToHex(pixel[0], pixel[1], pixel[2]);
        brushColor = hex;
        document.getElementById('primary-color').value = hex;
        addToColorHistory(hex);
    } else if (currentTool === 'text') {
        const text = prompt("Enter text:", "Text Layer");
        if (text) {
            // Construct Font String
            let fontStr = "";
            if (fontItalic) fontStr += "italic ";
            if (fontBold) fontStr += "bold ";
            fontStr += `${brushSize * 2}px ${fontFamily}`;

            layer.ctx.font = fontStr;
            layer.ctx.fillStyle = activeColor;
            layer.ctx.fillText(text, localX, localY);
            historyManager.saveState();
            renderCanvas();
        }
    } else if (currentTool === 'poly-lasso') {
        // Add point
        // Store global coords since selection mask is global
        polygonPoints.push([x, y]);
        renderCanvas();
    }
}

function commitPenPath() {
    const layer = layerManager.getActiveLayer();
    if (!layer || penPath.length === 0) return;

    layer.ctx.save();
    layer.ctx.beginPath();

    // Transform to local coordinates
    for (let pt of penPath) {
        const lx = pt.x - layer.x;
        const ly = pt.y - layer.y;

        if (pt.type === 'M') layer.ctx.moveTo(lx, ly);
        else if (pt.type === 'L') layer.ctx.lineTo(lx, ly);
        else if (pt.type === 'Q') layer.ctx.quadraticCurveTo(pt.cp1x - layer.x, pt.cp1y - layer.y, lx, ly);
        else if (pt.type === 'C') layer.ctx.bezierCurveTo(pt.cp1x - layer.x, pt.cp1y - layer.y, pt.cp2x - layer.x, pt.cp2y - layer.y, lx, ly);
    }

    layer.ctx.closePath();

    if (shapeFill) {
        layer.ctx.fillStyle = activeColor;
        layer.ctx.fill();
    }
    if (shapeStroke) {
        layer.ctx.strokeStyle = activeColor;
        layer.ctx.lineWidth = brushSize;
        layer.ctx.stroke();
    }

    layer.ctx.restore();
    historyManager.saveState();
    renderCanvas();
}

function handleDoubleClick(e) {
    if (currentTool === 'pen') {
        commitPenPath();
        penPath = [];
        renderCanvas();
        return;
    }

    if (currentTool === 'poly-lasso') {
        // Close polygon selection
        if (polygonPoints.length < 3) {
            polygonPoints = [];
            renderCanvas();
            return;
        }

        selectionManager.clearSelection();
        selectionManager.hasSelection = true;
        selectionManager.ctx.beginPath();
        selectionManager.ctx.moveTo(polygonPoints[0][0], polygonPoints[0][1]);
        for (let i = 1; i < polygonPoints.length; i++) {
            selectionManager.ctx.lineTo(polygonPoints[i][0], polygonPoints[i][1]);
        }
        selectionManager.ctx.closePath();
        selectionManager.ctx.fillStyle = 'rgba(0,0,0,1)';
        selectionManager.ctx.fill();

        polygonPoints = []; // Reset points
        renderCanvas();
        return;
    }

    if (currentTool === 'crop' && selectionManager.hasSelection) {
        // Find crop bounds from mask
        // Simple approach: using selectionManager startX, startY and current mouse (or last update)
        // But the user might have dragged in any direction.
        // We need the bounding box of the selection mask.
        // Since crop tool uses rect selection logic, we can track the rect coords.

        // Find bounds of non-transparent pixels in maskCanvas
        const w = selectionManager.width;
        const h = selectionManager.height;
        const imgData = selectionManager.ctx.getImageData(0, 0, w, h);
        const data = imgData.data;

        let minX = w, minY = h, maxX = 0, maxY = 0;
        let found = false;

        for(let y=0; y<h; y++) {
            for(let x=0; x<w; x++) {
                if(data[(y*w+x)*4 + 3] > 0) {
                    if(x < minX) minX = x;
                    if(x > maxX) maxX = x;
                    if(y < minY) minY = y;
                    if(y > maxY) maxY = y;
                    found = true;
                }
            }
        }

        if(found) {
            performCrop(minX, minY, maxX - minX + 1, maxY - minY + 1);
        }
    }
}

function performCrop(x, y, w, h) {
    if (w <= 0 || h <= 0) return;

    // Resize main canvas
    mainCanvas.width = w;
    mainCanvas.height = h;
    layerManager.width = w;
    layerManager.height = h;
    selectionManager.width = w;
    selectionManager.height = h;

    // Resize mask canvas
    selectionManager.maskCanvas.width = w;
    selectionManager.maskCanvas.height = h;

    // Adjust Layers
    layerManager.layers.forEach(layer => {
        // Shift layer position
        layer.x -= x;
        layer.y -= y;

        // Note: We don't necessarily need to crop the layer internal canvas,
        // just moving it is enough to "crop" the view.
        // But if we want to save memory or fully commit, we could crop them.
        // For now, simple shift is sufficient and non-destructive to layer data (except for canvas bounds).
    });

    selectionManager.clearSelection();
    historyManager.saveState();
    renderCanvas();

    // Reset view
    panX = 0;
    panY = 0;
    zoomLevel = 1;
}

function handleWheel(e) {
    e.preventDefault();
    const zoomIntensity = 0.1;
    const delta = e.deltaY < 0 ? 1 : -1;
    const zoomFactor = Math.exp(delta * zoomIntensity);

    const rect = mainCanvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const newZoom = zoomLevel * zoomFactor;

    if (newZoom < 0.1 || newZoom > 10) return;

    const worldX = (mouseX - panX) / zoomLevel;
    const worldY = (mouseY - panY) / zoomLevel;

    panX = mouseX - worldX * newZoom;
    panY = mouseY - worldY * newZoom;
    zoomLevel = newZoom;

    renderCanvas();
}


// --- Algorithms ---

function magicWandSelection(layer, startX, startY, tolerance) {
    // Magic Wand behaves like flood fill but populates selection mask
    const w = layer.canvas.width;
    const h = layer.canvas.height;
    const ctx = layer.ctx;

    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;

    const startPos = (startY * w + startX) * 4;
    const startColor = [data[startPos], data[startPos+1], data[startPos+2], data[startPos+3]];

    // Prepare selection mask context
    selectionManager.clearSelection();
    selectionManager.hasSelection = true;
    const maskImage = selectionManager.ctx.createImageData(w, h);
    const maskData = maskImage.data;

    const stack = [[startX, startY]];
    const visited = new Set(); // To avoid infinite loops or re-checking

    while(stack.length) {
        const [x, y] = stack.pop();
        const key = `${x},${y}`;
        if (visited.has(key)) continue;
        visited.add(key);

        const pos = (y * w + x) * 4;

        if (x < 0 || x >= w || y < 0 || y >= h) continue;

        // Color Match with Tolerance
        if (colorMatchTolerance(data, pos, startColor, tolerance)) {
            // Set mask pixel to opaque (selected)
            // But wait, mask is global. `x` and `y` here are local to layer.
            // We need to map local (x, y) to global mask coordinates.
            const globalX = Math.round(x + layer.x);
            const globalY = Math.round(y + layer.y);

            if (globalX >= 0 && globalX < selectionManager.width && globalY >= 0 && globalY < selectionManager.height) {
                const maskPos = (globalY * selectionManager.width + globalX) * 4;
                // Set mask red (visual debugging) or black/white
                maskData[maskPos] = 0;   // R
                maskData[maskPos+1] = 0; // G
                maskData[maskPos+2] = 255; // B (Blue tint)
                maskData[maskPos+3] = 255; // Alpha
            }

            stack.push([x+1, y]);
            stack.push([x-1, y]);
            stack.push([x, y+1]);
            stack.push([x, y-1]);
        }
    }

    selectionManager.ctx.putImageData(maskImage, 0, 0);
    renderCanvas();
}

function colorMatchTolerance(data, pos, target, tolerance) {
    const r = data[pos];
    const g = data[pos+1];
    const b = data[pos+2];
    const a = data[pos+3];

    // Simple Euclidean distance or just abs diff sum
    const diff = Math.abs(r - target[0]) + Math.abs(g - target[1]) + Math.abs(b - target[2]) + Math.abs(a - target[3]);
    return diff <= tolerance * 4;
}

// Flood Fill (Stack-based recursive simulation)
function floodFill(layer, startX, startY, fillColor) {
    // fillColor is [r, g, b, a] (0-255)
    const ctx = layer.ctx;
    const w = layer.canvas.width;
    const h = layer.canvas.height;

    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;

    // Get selection mask data if active
    let maskData = null;
    if (selectionManager.hasSelection) {
        maskData = selectionManager.ctx.getImageData(layer.x || 0, layer.y || 0, w, h).data;
    }

    const startPos = (startY * w + startX) * 4;
    const startColor = [data[startPos], data[startPos+1], data[startPos+2], data[startPos+3]];

    // Don't fill if color is same
    if (colorsMatch(startColor, fillColor)) return;

    const stack = [[startX, startY]];

    while(stack.length) {
        const [x, y] = stack.pop();
        const pos = (y * w + x) * 4;

        if (x < 0 || x >= w || y < 0 || y >= h) continue;

        if (maskData && maskData[pos + 3] === 0) continue;

        if (colorsMatch([data[pos], data[pos+1], data[pos+2], data[pos+3]], startColor)) {
            data[pos] = fillColor[0];
            data[pos+1] = fillColor[1];
            data[pos+2] = fillColor[2];
            data[pos+3] = fillColor[3]; // Alpha 255

            stack.push([x+1, y]);
            stack.push([x-1, y]);
            stack.push([x, y+1]);
            stack.push([x, y-1]);
        }
    }

    ctx.putImageData(imageData, 0, 0);
}

function colorsMatch(c1, c2) {
    return c1[0] === c2[0] && c1[1] === c2[1] && c1[2] === c2[2] && c1[3] === c2[3];
}

// --- Tool Logic ---
function setTool(tool) {
    currentTool = tool;

    // Reset path states
    if (tool !== 'pen') penPath = [];
    if (tool !== 'poly-lasso') polygonPoints = [];

    document.querySelectorAll('.tool').forEach(el => el.classList.remove('active'));

    // Find the tool element that matches the tool string and add active class
    const toolEl = document.querySelector(`.tool[onclick="setTool('${tool}')"]`);
    if (toolEl) {
        toolEl.classList.add('active');
    }

    mainCanvas.style.cursor = getCursorForTool(tool);

    // Toggle Options
    const isShape = ['rect', 'circle', 'rounded-rect', 'polygon', 'star', 'pen'].includes(tool);
    document.getElementById('shape-options').style.display = isShape ? 'flex' : 'none';
    document.getElementById('text-options').style.display = tool === 'text' ? 'flex' : 'none';
    document.getElementById('wand-options').style.display = tool === 'wand' ? 'flex' : 'none';
    document.getElementById('spray-options').style.display = tool === 'spray' ? 'flex' : 'none';

    const extraShapeOpts = document.getElementById('extra-shape-options');
    if (['polygon', 'star', 'rounded-rect'].includes(tool)) {
        extraShapeOpts.style.display = 'flex';
        const isPolyStar = ['polygon', 'star'].includes(tool);
        document.getElementById('sides-label').style.display = isPolyStar ? 'inline' : 'none';
        document.getElementById('shape-sides').style.display = isPolyStar ? 'inline' : 'none';

        document.getElementById('radius-label').style.display = tool === 'rounded-rect' ? 'inline' : 'none';
        document.getElementById('shape-radius').style.display = tool === 'rounded-rect' ? 'inline' : 'none';
    } else {
        extraShapeOpts.style.display = 'none';
    }

    // Reset Polygon Lasso state if switching away
    if (tool !== 'poly-lasso') {
        polygonPoints = [];
        renderCanvas(); // Redraw to clear preview
    }
}

function getCursorForTool(tool) {
    const advancedBrushes = ['smudge', 'blur-brush', 'sharpen-brush', 'dodge', 'burn', 'spray', 'watercolor', 'marker', 'pencil'];
    if(tool === 'brush' || tool === 'eraser' || tool === 'clone' || advancedBrushes.includes(tool)) return 'crosshair';
    else if(tool === 'pen') return 'crosshair'; // Usually pen tool has custom cursor, but crosshair works
    else if(tool === 'move') return 'move';
    else if(tool === 'text') return 'text';
    else if(tool === 'picker') return 'cell';
    else if(tool === 'crop') return 'crosshair';
    else if(tool === 'wand' || tool === 'gradient') return 'crosshair';
    return 'default';
}

function addToColorHistory(color) {
    if (colorHistory.includes(color)) return;
    colorHistory.unshift(color);
    if (colorHistory.length > 8) colorHistory.pop();

    const container = document.getElementById('color-history');
    container.innerHTML = '';

    colorHistory.forEach(c => {
        const div = document.createElement('div');
        div.style.width = '15px';
        div.style.height = '15px';
        div.style.backgroundColor = c;
        div.style.cursor = 'pointer';
        div.style.border = '1px solid #555';
        div.title = c;
        div.onclick = () => {
            brushColor = c;
            document.getElementById('primary-color').value = c;
        };
        container.appendChild(div);
    });
}

// --- Color Helpers ---
function hexToRgb(hex) {
    const bigint = parseInt(hex.slice(1), 16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return `${r},${g},${b}`;
}

function hexToRgba(hex) {
    const bigint = parseInt(hex.slice(1), 16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return [r, g, b, 255];
}

function rgbToHex(r, g, b) {
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

// --- File Operations ---
function downloadImage() {
    // We need to render the final image without zoom/pan for export
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = mainCanvas.width;
    exportCanvas.height = mainCanvas.height;
    const ctx = exportCanvas.getContext('2d');

    // Replicate renderCanvas logic but flat
    drawCheckerboard(ctx, exportCanvas.width, exportCanvas.height);
    layerManager.layers.forEach(layer => {
        if (!layer.visible) return;
        ctx.save();
        ctx.globalAlpha = layer.opacity;
        ctx.globalCompositeOperation = layer.blendMode;

        const centerX = (layer.x || 0) + layer.canvas.width / 2;
        const centerY = (layer.y || 0) + layer.canvas.height / 2;
        ctx.translate(centerX, centerY);
        ctx.rotate(layer.rotation || 0);
        ctx.scale(layer.scaleX || 1, layer.scaleY || 1);
        ctx.translate(-centerX, -centerY);

        ctx.drawImage(layer.canvas, layer.x || 0, layer.y || 0);
        ctx.restore();
    });

    const link = document.createElement('a');
    link.download = 'webphoto-export.jpg';
    link.href = exportCanvas.toDataURL('image/jpeg', 0.8);
    link.click();
}

function handleFileUpload(input) {
    const file = input.files[0];
    const reader = new FileReader();

    reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
            // Create new layer for imported image
            const layer = layerManager.addLayer(file.name);
            const x = (layer.canvas.width - img.width) / 2;
            const y = (layer.canvas.height - img.height) / 2;
            layer.ctx.drawImage(img, Math.max(0, x), Math.max(0, y), Math.min(layer.canvas.width, img.width), Math.min(layer.canvas.height, img.height));
            renderCanvas();
        }
        img.src = e.target.result;
    }
    reader.readAsDataURL(file);
}

function newFile() {
    if(confirm("Clear canvas and start new?")) {
        layerManager.layers = [];
        layerManager.layerCounter = 0;
        init();
    }
}

function saveProject() {
    const project = {
        width: layerManager.width,
        height: layerManager.height,
        layers: layerManager.layers.map(l => ({
            id: l.id,
            name: l.name,
            visible: l.visible,
            opacity: l.opacity,
            blendMode: l.blendMode,
            x: l.x,
            y: l.y,
            scaleX: l.scaleX,
            scaleY: l.scaleY,
            rotation: l.rotation,
            data: l.canvas.toDataURL()
        }))
    };

    const json = JSON.stringify(project);
    const blob = new Blob([json], {type: "application/json"});
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = "webphoto-project.json";
    link.click();
}

function loadProject(input) {
    const file = input.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const project = JSON.parse(e.target.result);
            if (!project.layers) throw new Error("Invalid project file");

            // Reset state
            layerManager.layers = [];
            layerManager.layerCounter = 0;

            // Resize canvas if needed
            if (project.width && project.height) {
                mainCanvas.width = project.width;
                mainCanvas.height = project.height;
                layerManager.width = project.width;
                layerManager.height = project.height;
                selectionManager.width = project.width;
                selectionManager.height = project.height;
                selectionManager.maskCanvas.width = project.width;
                selectionManager.maskCanvas.height = project.height;
            }

            // Load layers sequentially to maintain order
            let loaded = 0;

            project.layers.forEach((lData, index) => {
                const layer = new Layer(lData.id, lData.name, mainCanvas.width, mainCanvas.height);
                layer.visible = lData.visible;
                layer.opacity = lData.opacity;
                layer.blendMode = lData.blendMode;
                layer.x = lData.x;
                layer.y = lData.y;
                layer.scaleX = lData.scaleX;
                layer.scaleY = lData.scaleY;
                layer.rotation = lData.rotation;

                const img = new Image();
                img.onload = () => {
                    layer.ctx.drawImage(img, 0, 0);
                    loaded++;
                    if (loaded === project.layers.length) {
                        layerManager.activeLayerId = layerManager.layers[layerManager.layers.length-1].id;
                        renderLayerList();
                        renderCanvas();
                        historyManager.saveState();
                    }
                };
                img.src = lData.data;

                layerManager.layers.push(layer);
                // Update counter
                if (lData.id > layerManager.layerCounter) layerManager.layerCounter = lData.id;
            });

        } catch (err) {
            alert("Error loading project: " + err.message);
        }
    };
    reader.readAsText(file);
}

// --- Image Adjustments (Destructive) ---

// --- Real-Time Adjustments State ---
let isAdjusting = false;
let adjustmentSourceCanvas = null;
let currentActiveGroup = null;

function toggleActionGroup(groupId) {
    const group = document.getElementById(groupId);
    const btn = group.previousElementSibling;

    // If opening a new group, close others and reset adjustments
    if (group.classList.contains('hidden')) {
        // Reset all sliders back to default
        document.querySelectorAll('.visual-slider').forEach(s => {
            s.value = s.defaultValue;
        });

        // Hide all
        document.querySelectorAll('.action-sliders').forEach(el => el.classList.add('hidden'));
        document.querySelectorAll('.action-btn').forEach(el => el.classList.remove('open'));

        // Show target
        group.classList.remove('hidden');
        btn.classList.add('open');
        currentActiveGroup = groupId;

        // Capture original state for real-time preview
        captureAdjustmentSource();
    } else {
        // Closing group
        group.classList.add('hidden');
        btn.classList.remove('open');
        currentActiveGroup = null;
        cancelAdjustment();
    }
}

function captureAdjustmentSource() {
    const layer = layerManager.getActiveLayer();
    if (!layer || !layer.visible) return;

    // Save original pixel data of the active layer for non-destructive preview
    adjustmentSourceCanvas = document.createElement('canvas');
    adjustmentSourceCanvas.width = layer.canvas.width;
    adjustmentSourceCanvas.height = layer.canvas.height;
    adjustmentSourceCanvas.getContext('2d').drawImage(layer.canvas, 0, 0);
    isAdjusting = true;
}

function previewAdjustment() {
    if (!isAdjusting || !adjustmentSourceCanvas) return;
    const layer = layerManager.getActiveLayer();
    if (!layer || !layer.visible) return;

    // Restore from source canvas first
    layer.ctx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
    layer.ctx.drawImage(adjustmentSourceCanvas, 0, 0);

    // Determine which sliders to read
    if (currentActiveGroup === 'brightness-group') {
        const brightness = parseInt(document.getElementById('slider-brightness').value);
        const contrast = parseInt(document.getElementById('slider-contrast').value);
        if (brightness !== 0 || contrast !== 0) {
            applyRealtimeFilter(layer.ctx, w => applyBrightnessContrast(w, brightness, contrast));
        }
    } else if (currentActiveGroup === 'hue-group') {
        const hue = parseInt(document.getElementById('slider-hue').value);
        const sat = parseInt(document.getElementById('slider-saturation').value);
        if (hue !== 0 || sat !== 0) {
            applyRealtimeFilter(layer.ctx, w => applyHueSaturation(w, hue, sat));
        }
    } else if (currentActiveGroup === 'blur-group') {
        const radius = parseFloat(document.getElementById('slider-blur').value);
        if (radius > 0) {
            layer.ctx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
            layer.ctx.save();
            if (selectionManager.hasSelection) selectionManager.clipContext(layer.ctx);
            layer.ctx.filter = `blur(${radius}px)`;
            layer.ctx.drawImage(adjustmentSourceCanvas, 0, 0);
            layer.ctx.filter = 'none';
            layer.ctx.restore();

            // Re-draw unselected areas from source if there is a selection
            if (selectionManager.hasSelection) {
                layer.ctx.save();
                layer.ctx.globalCompositeOperation = 'destination-over';
                layer.ctx.drawImage(adjustmentSourceCanvas, 0, 0);
                layer.ctx.restore();
            }
        }
    } else if (currentActiveGroup === 'levels-group') {
        const gamma = parseFloat(document.getElementById('slider-levels').value);
        if (gamma !== 1.0) {
            applyRealtimeFilter(layer.ctx, w => applyGamma(w, gamma));
        }
    }

    renderCanvas();
}

function commitAdjustment() {
    if (!isAdjusting) return;

    // Save state to history after mouse release (change event)
    historyManager.saveState();

    // Update source canvas to the newly committed state
    captureAdjustmentSource();

    // Reset sliders so the next drag starts from 0 relative to the new baseline
    document.querySelectorAll('.visual-slider').forEach(s => {
         s.value = s.defaultValue;
    });
}

function cancelAdjustment() {
    if (!isAdjusting) return;
    isAdjusting = false;

    const layer = layerManager.getActiveLayer();
    if (layer && adjustmentSourceCanvas) {
         // Reset layer visually if we just closed without changing,
         // Though change event handles commit. We keep the committed version.
    }
    adjustmentSourceCanvas = null;

    // Reset sliders
    document.querySelectorAll('.visual-slider').forEach(s => {
         s.value = s.defaultValue;
    });
}

function applyRealtimeFilter(ctx, filterFunc) {
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    const imgData = ctx.getImageData(0, 0, w, h);

    let maskData = null;
    if (selectionManager.hasSelection) {
        maskData = selectionManager.ctx.getImageData(0, 0, w, h).data;
    }

    filterFunc({data: imgData.data, mask: maskData});
    ctx.putImageData(imgData, 0, 0);
}

// Processing algorithms for real-time
function applyBrightnessContrast(context, brightness, contrast) {
    const data = context.data;
    const mask = context.mask;
    const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));

    for (let i = 0; i < data.length; i += 4) {
        if (mask && mask[i+3] === 0) continue;

        for (let j = 0; j < 3; j++) {
            let val = data[i+j] + brightness;
            val = factor * (val - 128) + 128;
            data[i+j] = Math.min(255, Math.max(0, val));
        }
    }
}

function applyHueSaturation(context, hueShift, satShift) {
    const data = context.data;
    const mask = context.mask;
    const hueNormalized = hueShift / 360;
    const satMultiplier = satShift > 0 ? (1 + satShift/100) : (1 + satShift/100); // simplify
    // Actually standard saturation algorithm:
    // S = S + satShift/100 is not great. Better:
    // If satShift > 0: factor = 1 + (satShift/100)*2
    // If satShift < 0: factor = 1 + (satShift/100)

    for (let i = 0; i < data.length; i += 4) {
        if (mask && mask[i+3] === 0) continue;

        const [h, s, l] = rgbToHsl(data[i], data[i+1], data[i+2]);
        let newH = (h + hueNormalized) % 1;
        if (newH < 0) newH += 1;

        let newS = s;
        if (satShift > 0) newS = s + (1-s) * (satShift/100);
        else newS = s + s * (satShift/100);
        newS = Math.min(1, Math.max(0, newS));

        const [r, g, b] = hslToRgb(newH, newS, l);
        data[i] = r; data[i+1] = g; data[i+2] = b;
    }
}

function applyGamma(context, gamma) {
    const data = context.data;
    const mask = context.mask;
    for (let i = 0; i < data.length; i += 4) {
        if (mask && mask[i+3] === 0) continue;
        data[i] = 255 * Math.pow(data[i]/255, 1/gamma);
        data[i+1] = 255 * Math.pow(data[i+1]/255, 1/gamma);
        data[i+2] = 255 * Math.pow(data[i+2]/255, 1/gamma);
    }
}


function applyImageAdjustment(type) {
    const layer = layerManager.getActiveLayer();
    if (!layer || !layer.visible) {
        alert("No active layer selected.");
        return;
    }

    const ctx = layer.editingMask ? layer.maskCtx : layer.ctx;
    const w = layer.canvas.width;
    const h = layer.canvas.height;

    // Get pixel data
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;

    // Get selection mask
    let maskData = null;
    if (selectionManager.hasSelection) {
        maskData = selectionManager.ctx.getImageData(0, 0, w, h).data;
    }

    // Parameters & Convolution Filters
    let val;
    if (type === 'brightness') {
        const input = prompt("Enter Brightness (-100 to 100):", "0");
        if (input === null) return;
        val = parseInt(input) || 0;
    } else if (type === 'blur') {
        const input = prompt("Enter Blur Radius (0-20):", "5");
        if (input === null) return;
        val = parseInt(input) || 0;
        // Blur handled via canvas filter
        ctx.save();
        if (selectionManager.hasSelection) selectionManager.clipContext(ctx);
        ctx.filter = `blur(${val}px)`;
        ctx.drawImage(layer.canvas, 0, 0);
        ctx.filter = 'none';
        ctx.restore();
        historyManager.saveState();
        renderCanvas();
        return;
    } else if (type === 'sharpen' || type === 'emboss') {
        // Convolution Matrix
        let kernel = [];
        if (type === 'sharpen') {
            kernel = [0, -1, 0, -1, 5, -1, 0, -1, 0];
        } else if (type === 'emboss') {
            kernel = [-2, -1, 0, -1, 1, 1, 0, 1, 2];
        }
        applyConvolution(ctx, w, h, kernel, maskData);
        historyManager.saveState();
        renderCanvas();
        return;
    } else if (type === 'pixelate') {
        const input = prompt("Enter Block Size (2-100):", "10");
        if (input === null) return;
        val = parseInt(input) || 10;
        if(val < 1) val = 1;

        // Pixelate logic: Downscale by factor, then upscale
        // But for selection support, we need to be careful.
        // Easiest per-pixel approach:

        const newImageData = ctx.createImageData(w, h);
        const newData = newImageData.data;

        for (let y = 0; y < h; y += val) {
            for (let x = 0; x < w; x += val) {
                // Get average or center pixel
                const pIndex = (y * w + x) * 4;
                const r = data[pIndex];
                const g = data[pIndex + 1];
                const b = data[pIndex + 2];
                const a = data[pIndex + 3];

                for (let py = 0; py < val; py++) {
                    for (let px = 0; px < val; px++) {
                         if (x + px >= w || y + py >= h) continue;
                         const idx = ((y + py) * w + (x + px)) * 4;

                         // Check selection
                         if (maskData && maskData[idx+3] === 0) {
                             newData[idx] = data[idx];
                             newData[idx+1] = data[idx+1];
                             newData[idx+2] = data[idx+2];
                             newData[idx+3] = data[idx+3];
                         } else {
                             newData[idx] = r;
                             newData[idx+1] = g;
                             newData[idx+2] = b;
                             newData[idx+3] = a;
                         }
                    }
                }
            }
        }
        ctx.putImageData(newImageData, 0, 0);
        historyManager.saveState();
        renderCanvas();
        return;

    } else if (type === 'hue') {
        const input = prompt("Enter Hue Shift in Degrees (0-360):", "180");
        if (input === null) return;
        val = parseInt(input) || 0;
    } else if (type === 'noise') {
        const input = prompt("Enter Noise Amount (0-100):", "20");
        if (input === null) return;
        val = parseInt(input) || 20;
    } else if (type === 'vignette') {
        const input = prompt("Enter Vignette Strength (0-100):", "50");
        if (input === null) return;
        val = parseInt(input) || 50;
    } else if (type === 'levels') {
        const input = prompt("Enter Midpoint adjustment (0.1 to 9.9):", "1.0");
        if (input === null) return;
        val = parseFloat(input) || 1.0;
    } else if (type === 'color-balance') {
        const inputR = prompt("Red Balance (-100 to 100):", "0");
        const inputG = prompt("Green Balance (-100 to 100):", "0");
        const inputB = prompt("Blue Balance (-100 to 100):", "0");
        if (inputR === null || inputG === null || inputB === null) return;
        val = { r: parseInt(inputR)||0, g: parseInt(inputG)||0, b: parseInt(inputB)||0 };
    } else if (type === 'posterize') {
        const input = prompt("Levels per channel (2-256):", "4");
        if (input === null) return;
        val = parseInt(input) || 4;
        if (val < 2) val = 2;
    }

    // Process Pixels (Color Adjustments)
    for (let i = 0; i < data.length; i += 4) {
        // Skip unselected pixels
        if (maskData && maskData[i+3] === 0) continue;

        if (type === 'invert') {
            data[i] = 255 - data[i];     // R
            data[i+1] = 255 - data[i+1]; // G
            data[i+2] = 255 - data[i+2]; // B
        } else if (type === 'grayscale') {
            const avg = (data[i] + data[i+1] + data[i+2]) / 3;
            data[i] = avg;
            data[i+1] = avg;
            data[i+2] = avg;
        } else if (type === 'sepia') {
            const r = data[i], g = data[i+1], b = data[i+2];
            data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
            data[i+1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
            data[i+2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
        } else if (type === 'brightness') {
             // Simple additive brightness
            data[i] = Math.min(255, Math.max(0, data[i] + val));
            data[i+1] = Math.min(255, Math.max(0, data[i+1] + val));
            data[i+2] = Math.min(255, Math.max(0, data[i+2] + val));
        } else if (type === 'hue') {
            const [h, s, l] = rgbToHsl(data[i], data[i+1], data[i+2]);
            const newH = (h + val / 360) % 1;
            const [r, g, b] = hslToRgb(newH, s, l);
            data[i] = r; data[i+1] = g; data[i+2] = b;
        } else if (type === 'levels') {
             // Gamma correction formula: V_out = A * V_in ^ (1 / gamma)
             // simplified: 255 * (val/255)^(1/gamma)
             const gamma = val;
             data[i] = 255 * Math.pow(data[i]/255, 1/gamma);
             data[i+1] = 255 * Math.pow(data[i+1]/255, 1/gamma);
             data[i+2] = 255 * Math.pow(data[i+2]/255, 1/gamma);
        } else if (type === 'color-balance') {
             data[i] = Math.min(255, Math.max(0, data[i] + val.r));
             data[i+1] = Math.min(255, Math.max(0, data[i+1] + val.g));
             data[i+2] = Math.min(255, Math.max(0, data[i+2] + val.b));
        } else if (type === 'posterize') {
             const step = 255 / (val - 1);
             data[i] = Math.round(data[i] / step) * step;
             data[i+1] = Math.round(data[i+1] / step) * step;
             data[i+2] = Math.round(data[i+2] / step) * step;
        } else if (type === 'noise') {
            const rand = (Math.random() - 0.5) * val * 2;
            data[i] = Math.min(255, Math.max(0, data[i] + rand));
            data[i+1] = Math.min(255, Math.max(0, data[i+1] + rand));
            data[i+2] = Math.min(255, Math.max(0, data[i+2] + rand));
        } else if (type === 'vignette') {
            const x = (i / 4) % w;
            const y = Math.floor((i / 4) / w);
            const cx = w / 2;
            const cy = h / 2;
            const maxDist = Math.sqrt(cx*cx + cy*cy);
            const dist = Math.sqrt((x-cx)*(x-cx) + (y-cy)*(y-cy));
            const factor = 1 - (dist / maxDist) * (val / 100);

            data[i] *= factor;
            data[i+1] *= factor;
            data[i+2] *= factor;
        }
    }

    ctx.putImageData(imageData, 0, 0);
    historyManager.saveState();
    renderCanvas();
}

function applyConvolution(ctx, w, h, kernel, maskData) {
    const side = Math.round(Math.sqrt(kernel.length));
    const halfSide = Math.floor(side / 2);
    const srcData = ctx.getImageData(0, 0, w, h);
    const dstData = ctx.createImageData(w, h);
    const src = srcData.data;
    const dst = dstData.data;

    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            const dstOff = (y * w + x) * 4;

            // If masked out, copy original
            if (maskData && maskData[dstOff + 3] === 0) {
                dst[dstOff] = src[dstOff];
                dst[dstOff+1] = src[dstOff+1];
                dst[dstOff+2] = src[dstOff+2];
                dst[dstOff+3] = src[dstOff+3];
                continue;
            }

            let r = 0, g = 0, b = 0;
            for (let ky = 0; ky < side; ky++) {
                for (let kx = 0; kx < side; kx++) {
                    const scy = y + ky - halfSide;
                    const scx = x + kx - halfSide;
                    if (scy >= 0 && scy < h && scx >= 0 && scx < w) {
                        const srcOff = (scy * w + scx) * 4;
                        const wt = kernel[ky * side + kx];
                        r += src[srcOff] * wt;
                        g += src[srcOff + 1] * wt;
                        b += src[srcOff + 2] * wt;
                    }
                }
            }
            dst[dstOff] = r;
            dst[dstOff + 1] = g;
            dst[dstOff + 2] = b;
            dst[dstOff + 3] = src[dstOff + 3];
        }
    }
    ctx.putImageData(dstData, 0, 0);
}

// --- Histogram ---
function transformLayer(type) {
    const layer = layerManager.getActiveLayer();
    if (!layer) {
        alert("No active layer selected.");
        return;
    }

    if (type === 'scale') {
        const inputX = prompt("Enter Scale X (e.g., 1.0):", layer.scaleX || 1);
        if (inputX === null) return;
        const inputY = prompt("Enter Scale Y (e.g., 1.0):", layer.scaleY || (parseFloat(inputX) || 1)); // Default Y to X if not set
        if (inputY === null) return;

        const sx = parseFloat(inputX);
        const sy = parseFloat(inputY);

        if (!isNaN(sx) && !isNaN(sy)) {
            layer.scaleX = sx;
            layer.scaleY = sy;
            historyManager.saveState();
            renderCanvas();
        }
    } else if (type === 'rotate') {
        const currentDeg = (layer.rotation || 0) * (180 / Math.PI);
        const input = prompt("Enter Rotation (degrees):", Math.round(currentDeg));
        if (input !== null) {
            const deg = parseFloat(input);
            if (!isNaN(deg)) {
                layer.rotation = deg * (Math.PI / 180);
                historyManager.saveState();
                renderCanvas();
            }
        }
    }
}

function updateHistogram() {
    const canvas = document.getElementById('histogram-canvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;

    // Clear histogram
    ctx.clearRect(0, 0, w, h);

    // We want the histogram of the visible canvas.
    // However, mainCanvas is huge and might be transformed.
    // `renderCanvas` draws to `mainCtx`. But we might be mid-rendering.
    // To get accurate histogram of what user sees (the composition):
    // We need to access mainCtx pixel data.
    // But mainCtx has zoom/pan applied. `getImageData` is affected by backing store size, not transforms directly on returned array?
    // Actually getImageData gets pixels from the backing store.
    // Since we cleared and redrew everything on mainCanvas, its pixels are current composition.

    // Performance note: Reading 800x600 pixels every frame is heavy.
    // We should throttle this or do it only on idle/changes.
    // For this demo, we'll do it.

    // But `mainCanvas` might be huge if cropped larger?
    // And `getImageData` on hardware accel canvas can be slow.

    try {
        // Optimization: sample pixels? Or just do full.
        const imgData = mainCtx.getImageData(0, 0, mainCanvas.width, mainCanvas.height);
        const data = imgData.data;

        const rCounts = new Array(256).fill(0);
        const gCounts = new Array(256).fill(0);
        const bCounts = new Array(256).fill(0);

        let maxCount = 0;

        for (let i = 0; i < data.length; i += 4) {
            // Skip transparent pixels? Or count them? usually ignore alpha 0
            if (data[i+3] === 0) continue;

            rCounts[data[i]]++;
            gCounts[data[i+1]]++;
            bCounts[data[i+2]]++;
        }

        maxCount = Math.max(...rCounts, ...gCounts, ...bCounts);

        if (maxCount === 0) return;

        // Draw Histograms
        ctx.globalCompositeOperation = 'screen';

        // Draw Red
        ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
        drawChannel(ctx, w, h, rCounts, maxCount);

        // Draw Green
        ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
        drawChannel(ctx, w, h, gCounts, maxCount);

        // Draw Blue
        ctx.fillStyle = 'rgba(0, 0, 255, 0.5)';
        drawChannel(ctx, w, h, bCounts, maxCount);

        ctx.globalCompositeOperation = 'source-over';

    } catch (e) {
        // CORS issues if image imported from other domain?
        // Usually fine with file upload.
        console.error("Histogram error", e);
    }
}

function drawChannel(ctx, w, h, counts, max) {
    ctx.beginPath();
    ctx.moveTo(0, h);
    for (let i = 0; i < 256; i++) {
        const x = (i / 255) * w;
        const y = h - (counts[i] / max) * h;
        ctx.lineTo(x, y);
    }
    ctx.lineTo(w, h);
    ctx.closePath();
    ctx.fill();
}

// Helper: RGB <-> HSL
function rgbToHsl(r, g, b) {
    r /= 255, g /= 255, b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
        h = s = 0;
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return [h, s, l];
}

function hslToRgb(h, s, l) {
    let r, g, b;
    if (s === 0) {
        r = g = b = l;
    } else {
        const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }
    return [r * 255, g * 255, b * 255];
}


// --- Simulated AI Features ---

function showAILoading(show) {
    document.getElementById('ai-loading').style.display = show ? 'flex' : 'none';
}

function aiSimulate(action) {
    const layer = layerManager.getActiveLayer();
    if (!layer || !layer.visible) {
        alert("No active layer selected.");
        return;
    }

    if (action === 'fill' && !selectionManager.hasSelection) {
        alert("Generative Fill requires a selection.");
        return;
    }

    let promptText = "";
    if (action === 'txt2img') {
        promptText = prompt("Describe the image to generate:", "A cute robot painting");
        if (!promptText) return;
    } else if (action === 'fill') {
        promptText = prompt("What should AI generate here? (Leave empty for contextual fill)", "Surrounding background");
        if (promptText === null) return;
    } else if (action === 'style') {
        promptText = prompt("Enter style (e.g. 'Cyberpunk', 'Watercolor', 'Sketch'):", "Cyberpunk");
        if (!promptText) return;
    }

    showAILoading(true);

    // Simulate API delay
    setTimeout(() => {
        showAILoading(false);
        applyAIFeature(action, layer, promptText);
    }, 2500); // 2.5 seconds wait
}

function applyAIFeature(action, layer, promptText) {
    const w = layer.canvas.width;
    const h = layer.canvas.height;
    const ctx = layer.ctx;

    ctx.save();

    if (action === 'fill') {
        // Simulating generative fill inside selection mask
        if (selectionManager.hasSelection) {
             selectionManager.clipContext(ctx);

             // Draw noise/pattern
             const tempCanvas = document.createElement('canvas');
             tempCanvas.width = w;
             tempCanvas.height = h;
             const tCtx = tempCanvas.getContext('2d');

             const idata = tCtx.createImageData(w, h);
             const d = idata.data;
             for (let i = 0; i < d.length; i += 4) {
                 d[i] = Math.random() * 255;
                 d[i+1] = Math.random() * 255;
                 d[i+2] = Math.random() * 255;
                 d[i+3] = 255;
             }
             tCtx.putImageData(idata, 0, 0);

             // Blur to make it look like "content aware fill" blending
             tCtx.filter = 'blur(10px)';
             tCtx.drawImage(tempCanvas, 0, 0);

             ctx.drawImage(tempCanvas, 0, 0);

             // Optionally add text
             if (promptText) {
                 ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                 ctx.fillRect(0, 0, w, h);
                 ctx.fillStyle = '#000';
                 ctx.font = '20px Arial';
                 ctx.textAlign = 'center';
                 ctx.fillText("[AI: " + promptText + "]", w/2, h/2);
             }

             ctx.restore();
             selectionManager.clearSelection();
        }
    } else if (action === 'bg-remove') {
        // Simulating Background Removal
        // We do a very rough alpha threshold or inverted circle mask
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = w;
        tempCanvas.height = h;
        const tCtx = tempCanvas.getContext('2d');
        tCtx.drawImage(layer.canvas, 0, 0);

        const idata = tCtx.getImageData(0, 0, w, h);
        const d = idata.data;

        // Let's pretend anything near the edges is background.
        // We'll mask out a soft vignette.
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                const i = (y * w + x) * 4;
                const distFromCenter = Math.hypot(x - w/2, y - h/2);
                const maxDist = Math.hypot(w/2, h/2);

                if (distFromCenter > maxDist * 0.5) {
                    // Fade out
                    const fade = 1 - ((distFromCenter - maxDist * 0.5) / (maxDist * 0.5));
                    d[i+3] = Math.max(0, Math.min(255, d[i+3] * fade));
                }
            }
        }
        ctx.putImageData(idata, 0, 0);

    } else if (action === 'upscale') {
        // Actual 2x upscale using Native canvas scaling
        const newW = mainCanvas.width * 2;
        const newH = mainCanvas.height * 2;

        performCrop(0, 0, newW, newH); // This resizes managers and canvases

        // Now scale up all layers
        layerManager.layers.forEach(l => {
            const temp = document.createElement('canvas');
            temp.width = l.canvas.width;
            temp.height = l.canvas.height;
            temp.getContext('2d').drawImage(l.canvas, 0, 0);

            l.canvas.width = newW;
            l.canvas.height = newH;

            l.ctx.imageSmoothingEnabled = false; // Nearest neighbor for pixel art look? Or true for normal.
            l.ctx.imageSmoothingQuality = 'high';
            l.ctx.drawImage(temp, 0, 0, l.canvas.width/2, l.canvas.height/2, 0, 0, newW, newH);

            // Re-center
            l.x *= 2;
            l.y *= 2;
        });

        // Reset zoom to fit
        zoomLevel = 0.5;

    } else if (action === 'style') {
        // Simulate style transfer with simple convolution/color shift
        const idata = ctx.getImageData(0, 0, w, h);
        const d = idata.data;

        // Add extreme contrast and shift colors
        const styleHue = Math.random();

        for(let i=0; i<d.length; i+=4) {
            if (d[i+3] === 0) continue;

            let [h, s, l] = rgbToHsl(d[i], d[i+1], d[i+2]);

            s = Math.min(1, s * 1.5); // Boost saturation
            h = (h + styleHue) % 1; // Shift hue globally

            // Posterize
            l = Math.round(l * 5) / 5;

            let [r, g, b] = hslToRgb(h, s, l);
            d[i] = r; d[i+1] = g; d[i+2] = b;
        }
        ctx.putImageData(idata, 0, 0);

    } else if (action === 'txt2img') {
        // Generate a new layer with a placeholder image
        const newLayer = layerManager.addLayer("AI Image");
        const tCtx = newLayer.ctx;

        // Generate a funky gradient
        const grad = tCtx.createLinearGradient(0, 0, w, h);
        grad.addColorStop(0, `hsl(${Math.random() * 360}, 100%, 50%)`);
        grad.addColorStop(1, `hsl(${Math.random() * 360}, 100%, 50%)`);
        tCtx.fillStyle = grad;
        tCtx.fillRect(w/4, h/4, w/2, h/2); // Draw smaller box in center

        tCtx.fillStyle = '#fff';
        tCtx.font = '24px sans-serif';
        tCtx.textAlign = 'center';
        tCtx.fillText(promptText, w/2, h/2);
    }

    ctx.restore();
    historyManager.saveState();
    renderCanvas();
}

// --- Shortcuts ---
window.addEventListener('keydown', (e) => {
    if(e.code === 'Space') {
        isSpacePressed = true;
        mainCanvas.style.cursor = 'grab';
    }

    if(e.key === 'b') setTool('brush');
    if(e.key === 'e') setTool('eraser');
    if(e.key === 's') setTool('clone'); // S for Stamp
    if(e.key === 'g') {
        if(e.shiftKey) setTool('gradient');
        else setTool('fill');
    }
    if(e.key === 'i') setTool('picker');
    if(e.key === 'c') setTool('crop');
    if(e.key === 'r') setTool('rect');
    // if(e.key === 'c') setTool('circle'); // Conflict with crop
    if(e.key === 'l') setTool('lasso');
    if(e.key === 't') setTool('text');
    if(e.key === 'm') setTool('marquee');
    if(e.key === 'v') setTool('move');
    if(e.key === 'w') setTool('wand');
    if(e.key === 'Escape') selectionManager.clearSelection();
    if(e.key === '[' && brushSize > 1) { brushSize--; document.getElementById('brush-size').value = brushSize; }
    if(e.key === ']') { brushSize++; document.getElementById('brush-size').value = brushSize; }

    // Undo/Redo
    if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
        e.preventDefault();
        if (e.shiftKey) {
            historyManager.redo();
        } else {
            historyManager.undo();
        }
    }
    if ((e.ctrlKey || e.metaKey) && e.key === 'y') { // Windows standard redo
        e.preventDefault();
        historyManager.redo();
    }
});

window.addEventListener('keyup', (e) => {
    if(e.code === 'Space') {
        isSpacePressed = false;
        mainCanvas.style.cursor = getCursorForTool(currentTool);
        isPanning = false; // Stop panning if space released during drag
    }
});

// --- Menu Logic ---
function toggleMenu(menuId) {
    // Close other menus first
    const dropdowns = document.getElementsByClassName("dropdown-content");
    for (let i = 0; i < dropdowns.length; i++) {
        if (dropdowns[i].id !== menuId) {
            dropdowns[i].classList.remove('show');
        }
    }
    document.getElementById(menuId).classList.toggle("show");
}

function zoomIn() {
    zoomLevel *= 1.2;
    // Adjust pan to zoom towards center? Simple zoom center
    const cx = mainCanvas.width / 2;
    const cy = mainCanvas.height / 2;
    // panX = cx - (cx - panX) * 1.2;
    // panY = cy - (cy - panY) * 1.2;
    // Keeping it simple center zoom for menu click
    panX = panX * 1.2 - cx * 0.2;
    panY = panY * 1.2 - cy * 0.2;
    renderCanvas();
}

function zoomOut() {
    zoomLevel /= 1.2;
    const cx = mainCanvas.width / 2;
    const cy = mainCanvas.height / 2;
    panX = panX / 1.2 + cx * (1 - 1/1.2);
    panY = panY / 1.2 + cy * (1 - 1/1.2);
    renderCanvas();
}

function fitScreen() {
    zoomLevel = 1;
    panX = 0;
    panY = 0;
    renderCanvas();
}


// Close menus when clicking elsewhere
window.onclick = function(event) {
    if (!event.target.matches('.menu-item') && !event.target.matches('.menu-item *')) {
        const dropdowns = document.getElementsByClassName("dropdown-content");
        for (let i = 0; i < dropdowns.length; i++) {
            const openDropdown = dropdowns[i];
            if (openDropdown.classList.contains('show')) {
                openDropdown.classList.remove('show');
            }
        }
    }
}

// Initialize app
init();

</script>
</body>
</html>
